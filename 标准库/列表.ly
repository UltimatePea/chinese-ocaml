(* 骆言标准库 - 列表模块 *)
(* 提供列表操作和函数式编程工具 *)

模块 列表 = {
  导出: [
    (* 基本操作 *)
    ("长度", 函数类型 (列表类型 (类型变量 "a"), 整数类型));
    ("是否为空", 函数类型 (列表类型 (类型变量 "a"), 布尔类型));
    ("头部", 函数类型 (列表类型 (类型变量 "a"), 类型变量 "a"));
    ("尾部", 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a")));
    ("连接", 函数类型 (列表类型 (类型变量 "a"), 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a"))));
    ("反转", 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a")));
    
    (* 高阶函数 *)
    ("映射", 函数类型 (函数类型 (类型变量 "a", 类型变量 "b"), 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "b"))));
    ("过滤", 函数类型 (函数类型 (类型变量 "a", 布尔类型), 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a"))));
    ("折叠左", 函数类型 (函数类型 (类型变量 "b", 函数类型 (类型变量 "a", 类型变量 "b")), 函数类型 (类型变量 "b", 函数类型 (列表类型 (类型变量 "a"), 类型变量 "b"))));
    ("折叠右", 函数类型 (函数类型 (类型变量 "a", 函数类型 (类型变量 "b", 类型变量 "b")), 函数类型 (类型变量 "b", 函数类型 (列表类型 (类型变量 "a"), 类型变量 "b"))));
    ("查找", 函数类型 (函数类型 (类型变量 "a", 布尔类型), 函数类型 (列表类型 (类型变量 "a"), 类型变量 "a")));
    
    (* 列表构造 *)
    ("范围", 函数类型 (整数类型, 函数类型 (整数类型, 列表类型 (整数类型))));
    ("重复", 函数类型 (整数类型, 函数类型 (类型变量 "a", 列表类型 (类型变量 "a"))));
    ("取前n个", 函数类型 (整数类型, 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a"))));
    ("跳过n个", 函数类型 (整数类型, 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a"))));
    
    (* 排序和搜索 *)
    ("排序", 函数类型 (函数类型 (类型变量 "a", 函数类型 (类型变量 "a", 整数类型)), 函数类型 (列表类型 (类型变量 "a"), 列表类型 (类型变量 "a"))));
    ("包含", 函数类型 (类型变量 "a", 函数类型 (列表类型 (类型变量 "a"), 布尔类型)));
    ("索引", 函数类型 (整数类型, 函数类型 (列表类型 (类型变量 "a"), 类型变量 "a")));
  ];
  
  语句: [
    (* 基本操作 *)
    递归 让 长度 = 函数 lst ->
      匹配 lst 与
      | [] -> 0
      | [_; ...tail] -> 1 + 长度 tail;
    
    让 是否为空 = 函数 lst ->
      匹配 lst 与
      | [] -> 真
      | _ -> 假;
    
    让 头部 = 函数 lst ->
      匹配 lst 与
      | [head; ..._] -> head
      | [] -> 抛出异常 "空列表没有头部";
    
    让 尾部 = 函数 lst ->
      匹配 lst 与
      | [_; ...tail] -> tail
      | [] -> 抛出异常 "空列表没有尾部";
    
    递归 让 连接 = 函数 lst1 lst2 ->
      匹配 lst1 与
      | [] -> lst2
      | [head; ...tail] -> [head; ...连接 tail lst2];
    
    让 反转 = 函数 lst ->
      递归 让 反转辅助 = 函数 acc lst ->
        匹配 lst 与
        | [] -> acc
        | [head; ...tail] -> 反转辅助 [head; ...acc] tail
      在 反转辅助 [] lst;
    
    (* 高阶函数 *)
    递归 让 映射 = 函数 f lst ->
      匹配 lst 与
      | [] -> []
      | [head; ...tail] -> [f head; ...映射 f tail];
    
    递归 让 过滤 = 函数 pred lst ->
      匹配 lst 与
      | [] -> []
      | [head; ...tail] ->
        如果 pred head 那么
          [head; ...过滤 pred tail]
        否则
          过滤 pred tail;
    
    递归 让 折叠左 = 函数 f acc lst ->
      匹配 lst 与
      | [] -> acc
      | [head; ...tail] -> 折叠左 f (f acc head) tail;
    
    递归 让 折叠右 = 函数 f acc lst ->
      匹配 lst 与
      | [] -> acc
      | [head; ...tail] -> f head (折叠右 f acc tail);
    
    递归 让 查找 = 函数 pred lst ->
      匹配 lst 与
      | [] -> 抛出异常 "未找到满足条件的元素"
      | [head; ...tail] ->
        如果 pred head 那么 head
        否则 查找 pred tail;
    
    (* 列表构造 *)
    递归 让 范围 = 函数 开始 结束 ->
      如果 开始 > 结束 那么 []
      否则 [开始; ...范围 (开始 + 1) 结束];
    
    递归 让 重复 = 函数 次数 值 ->
      如果 次数 <= 0 那么 []
      否则 [值; ...重复 (次数 - 1) 值];
    
    递归 让 取前n个 = 函数 n lst ->
      如果 n <= 0 那么 []
      否则
        匹配 lst 与
        | [] -> []
        | [head; ...tail] -> [head; ...取前n个 (n - 1) tail];
    
    递归 让 跳过n个 = 函数 n lst ->
      如果 n <= 0 那么 lst
      否则
        匹配 lst 与
        | [] -> []
        | [_; ...tail] -> 跳过n个 (n - 1) tail;
    
    (* 简单排序实现 (插入排序) *)
    让 排序 = 函数 比较函数 lst ->
      递归 让 插入 = 函数 x sorted_lst ->
        匹配 sorted_lst 与
        | [] -> [x]
        | [head; ...tail] ->
          如果 比较函数 x head <= 0 那么 [x; head; ...tail]
          否则 [head; ...插入 x tail]
      在
      递归 让 插入排序 = 函数 lst ->
        匹配 lst 与
        | [] -> []
        | [head; ...tail] -> 插入 head (插入排序 tail)
      在 插入排序 lst;
    
    递归 让 包含 = 函数 元素 lst ->
      匹配 lst 与
      | [] -> 假
      | [head; ...tail] ->
        如果 head = 元素 那么 真
        否则 包含 元素 tail;
    
    递归 让 索引 = 函数 i lst ->
      如果 i < 0 那么 抛出异常 "索引不能为负数"
      否则
        匹配 lst 与
        | [] -> 抛出异常 "索引超出范围"
        | [head; ...tail] ->
          如果 i = 0 那么 head
          否则 索引 (i - 1) tail;
  ];
}
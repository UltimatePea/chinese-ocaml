(*
 * 词法分析器 - 将源代码文本转换为词法单元序列
 * 支持中文关键字和标识符
 *)

(* 引入基础模块 *)
使用 基础工具.工具库
使用 基础工具.位置信息
使用 基础工具.错误处理

(* 词法单元类型 *)
类型 词法单元类型 =
  (* 字面量 *)
  | 整数词法单元 的 整数
  | 浮点词法单元 的 浮点数
  | 字符串词法单元 的 字符串
  | 布尔词法单元 的 布尔值
  
  (* 标识符和关键字 *)
  | 标识符词法单元 的 字符串
  | 关键字词法单元 的 字符串
  
  (* 运算符 *)
  | 加号 | 减号 | 乘号 | 除号 | 模运算符
  | 等号 | 不等号 | 小于号 | 小于等于号 | 大于号 | 大于等于号
  | 逻辑与符号 | 逻辑或符号 | 逻辑非符号
  | 赋值符号 | 字符串连接符号
  
  (* 分隔符 *)
  | 左括号 | 右括号 | 左方括号 | 右方括号 | 左花括号 | 右花括号
  | 逗号 | 分号 | 冒号 | 点号 | 双冒号 | 箭头 | 管道符号
  
  (* 特殊 *)
  | 文件结束
  | 换行符

(* 带位置的词法单元 *)
类型 词法单元 = {
  类型: 词法单元类型;
  位置: 位置范围;
  原始文本: 字符串;
}

(* 词法分析器状态 *)
类型 词法分析器状态 = {
  输入: 字符串;
  mutable 当前位置: 位置;
  mutable 字符索引: 整数;
  文件名: 字符串;
  错误收集器: 错误收集器;
}

(* 中文关键字映射 *)
让 中文关键字表 = [
  ("让", "让");
  ("函数", "函数");
  ("如果", "如果");
  ("那么", "那么");
  ("否则", "否则");
  ("匹配", "匹配");
  ("的", "的");
  ("在", "在");
  ("类型", "类型");
  ("递归", "递归");
  ("和", "和");
  ("真", "真");
  ("假", "假");
  ("模块", "模块");
  ("使用", "使用");
  ("异常", "异常");
  ("抛出", "抛出");
  ("捕获", "捕获");
  ("当", "当");
  ("while", "while");  (* 保留英文关键字作为备选 *)
  ("for", "for");
  ("break", "break");
  ("continue", "continue");
]

(* 检查是否是关键字 *)
让 是关键字 = 函数 标识符 ->
  List.exists (函数 (关键字, _) -> 关键字 = 标识符) 中文关键字表

(* 创建词法分析器状态 *)
让 创建词法分析器 = 函数 输入 文件名 ->
  let 错误收集器 = 创建错误收集器 () 在 {
    输入 = 输入;
    当前位置 = 创建初始位置 文件名;
    字符索引 = 0;
    文件名 = 文件名;
    错误收集器 = 错误收集器;
  }

(* 获取当前字符 *)
让 当前字符 = 函数 状态 ->
  if 状态.字符索引 >= 字符串长度 状态.输入 then
    无
  else
    有 (状态.输入.[状态.字符索引])

(* 前进一个字符 *)
让 前进字符 = 函数 状态 ->
  匹配 当前字符 状态 的
  | 无 -> ()
  | 有 字符 ->
      状态.当前位置 := 前进位置 状态.当前位置 字符;
      状态.字符索引 := 状态.字符索引 + 1

(* 跳过空白字符 *)
让 递归 跳过空白 = 函数 状态 ->
  匹配 当前字符 状态 的
  | 有 (' ' | '\t' | '\r') ->
      前进字符 状态;
      跳过空白 状态
  | _ -> ()

(* 跳过注释 *)
让 递归 跳过行注释 = 函数 状态 ->
  匹配 当前字符 状态 的
  | 有 '\n' | 无 -> ()
  | 有 _ ->
      前进字符 状态;
      跳过行注释 状态

(* 读取标识符或关键字 *)
让 读取标识符 = 函数 状态 ->
  let 开始位置 = 状态.当前位置 在
  let 缓冲区 = ref "" 在
  
  let 递归 读取字符 = 函数 () ->
    匹配 当前字符 状态 的
    | 有 字符 when 是字母或数字或下划线 字符 ->
        缓冲区 := !缓冲区 ^ (字符转字符串 字符);
        前进字符 状态;
        读取字符 ()
    | _ -> !缓冲区
  在
  
  let 标识符 = 读取字符 () 在
  let 结束位置 = 状态.当前位置 在
  let 位置范围 = 创建位置范围 开始位置 结束位置 在
  
  if 是关键字 标识符 then
    关键字词法单元 标识符
  else
    标识符词法单元 标识符

(* 读取数字字面量 *)
让 读取数字 = 函数 状态 ->
  let 开始位置 = 状态.当前位置 在
  let 缓冲区 = ref "" 在
  let 是浮点数 = ref false 在
  
  let 递归 读取数字字符 = 函数 () ->
    匹配 当前字符 状态 的
    | 有 字符 when 是数字 字符 ->
        缓冲区 := !缓冲区 ^ (字符转字符串 字符);
        前进字符 状态;
        读取数字字符 ()
    | 有 '.' when not !是浮点数 ->
        是浮点数 := true;
        缓冲区 := !缓冲区 ^ ".";
        前进字符 状态;
        读取数字字符 ()
    | _ -> !缓冲区
  在
  
  let 数字字符串 = 读取数字字符 () 在
  let 结束位置 = 状态.当前位置 在
  let 位置范围 = 创建位置范围 开始位置 结束位置 在
  
  if !是浮点数 then
    浮点词法单元 (字符串转浮点数 数字字符串)
  else
    整数词法单元 (字符串转整数 数字字符串)

(* 读取字符串字面量 *)
让 读取字符串字面量 = 函数 状态 ->
  let 开始位置 = 状态.当前位置 在
  let 缓冲区 = ref "" 在
  
  (* 跳过开始的引号 *)
  前进字符 状态;
  
  let 递归 读取字符串字符 = 函数 () ->
    匹配 当前字符 状态 的
    | 无 ->
        添加编译错误 状态.错误收集器 
          (词法错误 ("未终止的字符串字面量", 状态.当前位置));
        !缓冲区
    | 有 '"' ->
        前进字符 状态;  (* 跳过结束引号 *)
        !缓冲区
    | 有 '\\' ->
        前进字符 状态;
        匹配 当前字符 状态 的
        | 有 'n' -> 缓冲区 := !缓冲区 ^ "\n"; 前进字符 状态
        | 有 't' -> 缓冲区 := !缓冲区 ^ "\t"; 前进字符 状态
        | 有 'r' -> 缓冲区 := !缓冲区 ^ "\r"; 前进字符 状态
        | 有 '\\' -> 缓冲区 := !缓冲区 ^ "\\"; 前进字符 状态
        | 有 '"' -> 缓冲区 := !缓冲区 ^ "\""; 前进字符 状态
        | 有 字符 -> 
            缓冲区 := !缓冲区 ^ (字符转字符串 字符);
            前进字符 状态
        | 无 -> 
            添加编译错误 状态.错误收集器 
              (词法错误 ("未终止的转义序列", 状态.当前位置))
        end;
        读取字符串字符 ()
    | 有 字符 ->
        缓冲区 := !缓冲区 ^ (字符转字符串 字符);
        前进字符 状态;
        读取字符串字符 ()
  在
  
  let 字符串内容 = 读取字符串字符 () 在
  let 结束位置 = 状态.当前位置 在
  let 位置范围 = 创建位置范围 开始位置 结束位置 在
  
  字符串词法单元 字符串内容

(* 读取双字符运算符 *)
让 尝试读取双字符运算符 = 函数 状态 第一字符 ->
  if 状态.字符索引 + 1 >= 字符串长度 状态.输入 then
    无
  else
    let 第二字符 = 状态.输入.[状态.字符索引 + 1] 在
    匹配 (第一字符, 第二字符) 的
    | ('=', '=') -> 有 等号
    | ('!', '=') -> 有 不等号
    | ('<', '=') -> 有 小于等于号
    | ('>', '=') -> 有 大于等于号
    | ('&', '&') -> 有 逻辑与符号
    | ('|', '|') -> 有 逻辑或符号
    | (':', ':') -> 有 双冒号
    | ('-', '>') -> 有 箭头
    | ('^', '^') -> 有 字符串连接符号
    | _ -> 无

(* 词法分析主函数 *)
让 获取下一个词法单元 = 函数 状态 ->
  跳过空白 状态;
  
  let 开始位置 = 状态.当前位置 在
  
  匹配 当前字符 状态 的
  | 无 -> {
      类型 = 文件结束;
      位置 = 创建位置范围 开始位置 开始位置;
      原始文本 = "";
    }
  
  | 有 '\n' ->
      let 结束位置 = 状态.当前位置 在
      前进字符 状态;
      {
        类型 = 换行符;
        位置 = 创建位置范围 开始位置 结束位置;
        原始文本 = "\n";
      }
  
  (* 注释 *)
  | 有 '#' ->
      跳过行注释 状态;
      获取下一个词法单元 状态  (* 递归获取下一个有效词法单元 *)
  
  (* 字符串字面量 *)
  | 有 '"' ->
      let 词法单元类型 = 读取字符串字面量 状态 在
      let 结束位置 = 状态.当前位置 在
      {
        类型 = 词法单元类型;
        位置 = 创建位置范围 开始位置 结束位置;
        原始文本 = "字符串";  (* 简化 *)
      }
  
  (* 数字 *)
  | 有 字符 when 是数字 字符 ->
      let 词法单元类型 = 读取数字 状态 在
      let 结束位置 = 状态.当前位置 在
      {
        类型 = 词法单元类型;
        位置 = 创建位置范围 开始位置 结束位置;
        原始文本 = "数字";  (* 简化 *)
      }
  
  (* 标识符和关键字 *)
  | 有 字符 when 是字母或中文 字符 ->
      let 词法单元类型 = 读取标识符 状态 在
      let 结束位置 = 状态.当前位置 在
      {
        类型 = 词法单元类型;
        位置 = 创建位置范围 开始位置 结束位置;
        原始文本 = "标识符";  (* 简化 *)
      }
  
  (* 运算符和分隔符 *)
  | 有 字符 ->
      (* 首先尝试双字符运算符 *)
      匹配 尝试读取双字符运算符 状态 字符 的
      | 有 双字符运算符 ->
          前进字符 状态;  (* 跳过第一个字符 *)
          前进字符 状态;  (* 跳过第二个字符 *)
          let 结束位置 = 状态.当前位置 在
          {
            类型 = 双字符运算符;
            位置 = 创建位置范围 开始位置 结束位置;
            原始文本 = "双字符运算符";
          }
      | 无 ->
          (* 单字符运算符或分隔符 *)
          let 词法单元类型 = 匹配 字符 的
            | '+' -> 加号
            | '-' -> 减号
            | '*' -> 乘号
            | '/' -> 除号
            | '%' -> 模运算符
            | '=' -> 赋值符号
            | '<' -> 小于号
            | '>' -> 大于号
            | '!' -> 逻辑非符号
            | '(' -> 左括号
            | ')' -> 右括号
            | '[' -> 左方括号
            | ']' -> 右方括号
            | '{' -> 左花括号
            | '}' -> 右花括号
            | ',' -> 逗号
            | ';' -> 分号
            | ':' -> 冒号
            | '.' -> 点号
            | '|' -> 管道符号
            | _ -> 
                添加编译错误 状态.错误收集器 
                  (词法错误 ("未识别的字符: " ^ (字符转字符串 字符), 状态.当前位置));
                标识符词法单元 "错误"
          在
          前进字符 状态;
          let 结束位置 = 状态.当前位置 在
          {
            类型 = 词法单元类型;
            位置 = 创建位置范围 开始位置 结束位置;
            原始文本 = 字符转字符串 字符;
          }

(* 词法分析入口函数 *)
让 词法分析 = 函数 输入 文件名 ->
  let 状态 = 创建词法分析器 输入 文件名 在
  let 词法单元列表 = ref [] 在
  
  let 递归 收集词法单元 = 函数 () ->
    let 词法单元 = 获取下一个词法单元 状态 在
    词法单元列表 := 词法单元 :: !词法单元列表;
    匹配 词法单元.类型 的
    | 文件结束 -> List.rev !词法单元列表
    | _ -> 收集词法单元 ()
  在
  
  let 结果词法单元 = 收集词法单元 () 在
  
  if 有错误 状态.错误收集器 then
    创建失败结果 状态.错误收集器
  else
    创建成功结果 结果词法单元 状态.错误收集器

(* 辅助函数定义 *)
让 是数字 = 函数 字符 ->
  字符 >= '0' && 字符 <= '9'

让 是字母 = 函数 字符 ->
  (字符 >= 'a' && 字符 <= 'z') || (字符 >= 'A' && 字符 <= 'Z')

让 是中文 = 函数 字符 ->
  (* 简化的中文字符检测，实际实现需要更完整的Unicode范围 *)
  let 代码 = Char.code 字符 在
  代码 >= 0x4e00 && 代码 <= 0x9fff

让 是字母或中文 = 函数 字符 ->
  (是字母 字符) || (是中文 字符)

让 是字母或数字或下划线 = 函数 字符 ->
  (是字母或中文 字符) || (是数字 字符) || 字符 = '_'
(*
 * 类型系统 - 类型检查和类型推导
 * 实现骆言语言的类型检查系统
 *)

「：引入基础模块：」
使用 基础工具.工具库
使用 基础工具.位置信息
使用 基础工具.错误处理
使用 基础工具.抽象语法树

「：类型变量计数器：」
设 mutable 类型变量计数器 为 0

「：重置类型变量计数器：」
夫 重置类型变量计数器 者 受 () 焉 算法 乃
  类型变量计数器 := 0
是谓

「：生成新的类型变量：」
夫 生成类型变量 者 受 () 焉 算法 乃
  类型变量计数器 := 类型变量计数器 + 1;
  "t" ^ (字符串化整数 类型变量计数器)
是谓

「：内部类型表示：」
类型 内部类型 =
  | 基础类型 的 字符串
  | 类型变量 的 字符串
  | 函数类型 的 内部类型 * 内部类型
  | 元组类型 的 内部类型 列表
  | 列表类型 的 内部类型
  | 记录类型 的 (字符串 * 内部类型) 列表
  | 变体类型 的 字符串 * 内部类型 列表
  | 引用类型 的 内部类型
  | 数组类型 的 内部类型

「：类型约束：」
类型 类型约束 = 内部类型 * 内部类型

「：类型环境：」
类型 类型环境 = {
  变量类型: (字符串, 内部类型) 字典;
  类型定义: (字符串, 内部类型) 字典;
  类型约束: 类型约束 列表 参考;
}

「：创建类型环境：」
夫 创建类型环境 者 受 () 焉 算法 乃
  {
    变量类型 = 创建字典 ();
    类型定义 = 创建字典 ();
    类型约束 = 参考 [];
  }
是谓

「：复制类型环境：」
夫 复制类型环境 者 受 环境 焉 算法 乃
  {
    变量类型 = 复制字典 环境.变量类型;
    类型定义 = 复制字典 环境.类型定义;
    类型约束 = 参考 !(环境.类型约束);
  }
是谓

「：在类型环境中绑定变量类型：」
夫 绑定变量类型 者 受 环境 变量名 类型 焉 算法 乃
  字典添加 环境.变量类型 变量名 类型
是谓

「：在类型环境中查找变量类型：」
夫 查找变量类型 者 受 环境 变量名 焉 算法 乃
  若 字典包含键 环境.变量类型 变量名 则 答
    有 (字典获取 环境.变量类型 变量名)
  余者 答
    无
是谓

「：添加类型约束：」
夫 添加类型约束 者 受 环境 类型1 类型2 焉 算法 乃
  环境.类型约束 := (类型1, 类型2) :: !(环境.类型约束)
是谓

「：类型相等检查：」
夫 递归 类型相等 者 受 类型1 类型2 焉 算法 乃
  观 (类型1, 类型2) 之 性
  | (基础类型 名称1, 基础类型 名称2) -> 名称1 = 名称2
  | (类型变量 变量1, 类型变量 变量2) -> 变量1 = 变量2
  | (函数类型 (参数1, 返回1), 函数类型 (参数2, 返回2)) ->
      类型相等 参数1 参数2 && 类型相等 返回1 返回2
  | (元组类型 类型列表1, 元组类型 类型列表2) ->
      List.length 类型列表1 = List.length 类型列表2 &&
      List.for_all2 类型相等 类型列表1 类型列表2
  | (列表类型 元素类型1, 列表类型 元素类型2) ->
      类型相等 元素类型1 元素类型2
  | (引用类型 内容类型1, 引用类型 内容类型2) ->
      类型相等 内容类型1 内容类型2
  | (数组类型 元素类型1, 数组类型 元素类型2) ->
      类型相等 元素类型1 元素类型2
  | _ -> false
  观毕
是谓

「：类型统一算法：」
夫 递归 统一类型 者 受 环境 类型1 类型2 焉 算法 乃
  若 类型相等 类型1 类型2 则 答
    成功 ()
  余者 答
    观 (类型1, 类型2) 之 性
    | (类型变量 变量, 类型) | (类型, 类型变量 变量) ->
        若 类型包含变量 类型 变量 则 答
          错误 ("循环类型约束: " ^ 变量 ^ " 出现在 " ^ (格式化类型 类型))
        余者 答 (
          添加类型约束 环境 (类型变量 变量) 类型;
          成功 ()
        )
    | (函数类型 (参数1, 返回1), 函数类型 (参数2, 返回2)) ->
        观 统一类型 环境 参数1 参数2 之 性
        | 错误 信息 -> 错误 信息
        | 成功 () -> 统一类型 环境 返回1 返回2
        观毕
    | (元组类型 类型列表1, 元组类型 类型列表2) ->
        若 List.length 类型列表1 <> List.length 类型列表2 则 答
          错误 ("元组长度不匹配")
        余者 答
          统一类型列表 环境 类型列表1 类型列表2
    | (列表类型 元素类型1, 列表类型 元素类型2) ->
        统一类型 环境 元素类型1 元素类型2
    | (引用类型 内容类型1, 引用类型 内容类型2) ->
        统一类型 环境 内容类型1 内容类型2
    | (数组类型 元素类型1, 数组类型 元素类型2) ->
        统一类型 环境 元素类型1 元素类型2
    | _ ->
        错误 ("无法统一类型: " ^ (格式化类型 类型1) ^ " 和 " ^ (格式化类型 类型2))
    观毕
是谓

且有 统一类型列表 者 受 环境 类型列表1 类型列表2 焉 算法 乃
  观 (类型列表1, 类型列表2) 之 性
  | ([], []) -> 成功 ()
  | (类型1 :: 其余1, 类型2 :: 其余2) ->
      观 统一类型 环境 类型1 类型2 之 性
      | 错误 信息 -> 错误 信息
      | 成功 () -> 统一类型列表 环境 其余1 其余2
      观毕
  | _ -> 错误 ("类型列表长度不匹配")
  观毕
是谓

且有 类型包含变量 者 受 类型 变量 焉 算法 乃
  观 类型 之 性
  | 基础类型 _ -> false
  | 类型变量 变量名 -> 变量名 = 变量
  | 函数类型 (参数类型, 返回类型) ->
      类型包含变量 参数类型 变量 || 类型包含变量 返回类型 变量
  | 元组类型 类型列表 ->
      List.exists (夫 _ 者 受 类型 焉 算法 乃 类型包含变量 类型 变量 是谓) 类型列表
  | 列表类型 元素类型 ->
      类型包含变量 元素类型 变量
  | 记录类型 字段列表 ->
      List.exists (夫 _ 者 受 (_, 类型) 焉 算法 乃 类型包含变量 类型 变量 是谓) 字段列表
  | 变体类型 (_, 参数类型列表) ->
      List.exists (夫 _ 者 受 类型 焉 算法 乃 类型包含变量 类型 变量 是谓) 参数类型列表
  | 引用类型 内容类型 ->
      类型包含变量 内容类型 变量
  | 数组类型 元素类型 ->
      类型包含变量 元素类型 变量
  观毕
是谓

且有 格式化类型 者 受 类型 焉 算法 乃
  观 类型 之 性
  | 基础类型 名称 -> 名称
  | 类型变量 变量 -> "'" ^ 变量
  | 函数类型 (参数类型, 返回类型) ->
      "(" ^ (格式化类型 参数类型) ^ " -> " ^ (格式化类型 返回类型) ^ ")"
  | 元组类型 类型列表 ->
      "(" ^ (字符串连接 " * " (List.map 格式化类型 类型列表)) ^ ")"
  | 列表类型 元素类型 ->
      (格式化类型 元素类型) ^ " 列表"
  | 记录类型 字段列表 ->
      "{ " ^ (字符串连接 "; " (List.map (夫 _ 者 受 (名称, 类型) 焉 算法 乃
        名称 ^ ": " ^ (格式化类型 类型) 是谓) 字段列表)) ^ " }"
  | 变体类型 (名称, 参数类型列表) ->
      名称 ^ (若 参数类型列表 = [] 则 答 "" 
              余者 答 " (" ^ (字符串连接 " * " (List.map 格式化类型 参数类型列表)) ^ ")")
  | 引用类型 内容类型 ->
      (格式化类型 内容类型) ^ " 引用"
  | 数组类型 元素类型 ->
      (格式化类型 元素类型) ^ " 数组"
  观毕
是谓

「：从类型表达式转换为内部类型：」
夫 递归 类型表达式到内部类型 者 受 环境 类型表达式 焉 算法 乃
  观 类型表达式 之 性
  | 基础类型 (名称, _) -> 基础类型 名称
  | 类型变量 (变量, _) -> 类型变量 变量
  | 函数类型 (参数类型, 返回类型, _) ->
      设 参数 为 类型表达式到内部类型 环境 参数类型 在
      设 返回 为 类型表达式到内部类型 环境 返回类型 在
      函数类型 (参数, 返回)
  | 元组类型 (类型列表, _) ->
      设 内部类型列表 为 List.map (类型表达式到内部类型 环境) 类型列表 在
      元组类型 内部类型列表
  | 列表类型 (元素类型, _) ->
      设 元素 为 类型表达式到内部类型 环境 元素类型 在
      列表类型 元素
  | 记录类型 (字段列表, _) ->
      设 内部字段列表 为 List.map (夫 _ 者 受 (名称, 类型) 焉 算法 乃
        (名称, 类型表达式到内部类型 环境 类型) 是谓) 字段列表 在
      记录类型 内部字段列表
  | 变体类型 (名称, 参数类型列表, _) ->
      设 内部参数类型列表 为 List.map (类型表达式到内部类型 环境) 参数类型列表 在
      变体类型 (名称, 内部参数类型列表)
  | 引用类型 (内容类型, _) ->
      设 内容 为 类型表达式到内部类型 环境 内容类型 在
      引用类型 内容
  | 数组类型 (元素类型, _) ->
      设 元素 为 类型表达式到内部类型 环境 元素类型 在
      数组类型 元素
  观毕
是谓

「：推导字面量类型：」
夫 推导字面量类型 者 受 字面量 焉 算法 乃
  观 字面量 之 性
  | 整数字面量 _ -> 基础类型 "整数"
  | 浮点字面量 _ -> 基础类型 "浮点数"
  | 字符串字面量 _ -> 基础类型 "字符串"
  | 布尔字面量 _ -> 基础类型 "布尔值"
  | 单元字面量 -> 基础类型 "单元"
  观毕
是谓

「：推导二元运算类型：」
夫 推导二元运算类型 者 受 运算符 左类型 右类型 焉 算法 乃
  观 运算符 之 性
  | 加法 | 减法 | 乘法 | 除法 | 模运算 ->
      若 类型相等 左类型 (基础类型 "整数") && 类型相等 右类型 (基础类型 "整数") 则 答
        成功 (基础类型 "整数")
      余者 若 类型相等 左类型 (基础类型 "浮点数") && 类型相等 右类型 (基础类型 "浮点数") 则 答
        成功 (基础类型 "浮点数")
      余者 答
        错误 ("算术运算要求数值类型")
  | 等于 | 不等于 ->
      若 类型相等 左类型 右类型 则 答
        成功 (基础类型 "布尔值")
      余者 答
        错误 ("相等比较要求相同类型")
  | 小于 | 小于等于 | 大于 | 大于等于 ->
      若 (类型相等 左类型 (基础类型 "整数") && 类型相等 右类型 (基础类型 "整数")) ||
         (类型相等 左类型 (基础类型 "浮点数") && 类型相等 右类型 (基础类型 "浮点数")) 则 答
        成功 (基础类型 "布尔值")
      余者 答
        错误 ("数值比较要求数值类型")
  | 逻辑与 | 逻辑或 ->
      若 类型相等 左类型 (基础类型 "布尔值") && 类型相等 右类型 (基础类型 "布尔值") 则 答
        成功 (基础类型 "布尔值")
      余者 答
        错误 ("逻辑运算要求布尔类型")
  | 字符串连接 ->
      若 类型相等 左类型 (基础类型 "字符串") && 类型相等 右类型 (基础类型 "字符串") 则 答
        成功 (基础类型 "字符串")
      余者 答
        错误 ("字符串连接要求字符串类型")
  观毕
是谓

「：推导一元运算类型：」
夫 推导一元运算类型 者 受 运算符 操作数类型 焉 算法 乃
  观 运算符 之 性
  | 逻辑非 ->
      若 类型相等 操作数类型 (基础类型 "布尔值") 则 答
        成功 (基础类型 "布尔值")
      余者 答
        错误 ("逻辑非运算要求布尔类型")
  | 数值取反 ->
      若 类型相等 操作数类型 (基础类型 "整数") 则 答
        成功 (基础类型 "整数")
      余者 若 类型相等 操作数类型 (基础类型 "浮点数") 则 答
        成功 (基础类型 "浮点数")
      余者 答
        错误 ("数值取反要求数值类型")
  观毕
是谓

「：初始化基础类型环境：」
夫 初始化基础类型环境 者 受 环境 焉 算法 乃
  字典添加 环境.类型定义 "整数" (基础类型 "整数");
  字典添加 环境.类型定义 "浮点数" (基础类型 "浮点数");
  字典添加 环境.类型定义 "字符串" (基础类型 "字符串");
  字典添加 环境.类型定义 "布尔值" (基础类型 "布尔值");
  字典添加 环境.类型定义 "单元" (基础类型 "单元")
是谓
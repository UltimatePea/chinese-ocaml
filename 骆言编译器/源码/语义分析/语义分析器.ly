(*
 * 语义分析器 - 主要的语义分析入口
 * 整合符号表管理和类型检查功能
 *)

(* 引入基础模块 *)
使用 基础工具.工具库
使用 基础工具.位置信息
使用 基础工具.错误处理
使用 基础工具.抽象语法树
使用 语义分析.符号表
使用 语义分析.类型系统

(* 语义分析上下文 *)
类型 语义分析上下文 = {
  符号表: 符号表;
  类型环境: 类型环境;
  错误收集器: 错误收集器;
  当前函数返回类型: 内部类型 选项 参考;
  在循环中: 布尔值 参考;
}

(* 创建语义分析上下文 *)
让 创建语义分析上下文 = 函数 错误收集器 ->
  let 符号表 = 创建符号表 错误收集器 在
  let 类型环境 = 创建类型环境 () 在
  初始化全局符号 符号表;
  初始化基础类型环境 类型环境;
  {
    符号表 = 符号表;
    类型环境 = 类型环境;
    错误收集器 = 错误收集器;
    当前函数返回类型 = 参考 无;
    在循环中 = 参考 false;
  }

(* 分析表达式并推导其类型 *)
让 递归 分析表达式 = 函数 上下文 表达式 ->
  匹配 表达式 的
  | 字面量表达式 (字面量, 位置) ->
      推导字面量类型 字面量
      
  | 变量表达式 (名称, 位置) ->
      匹配 查找符号或报错 上下文.符号表 名称 位置 的
      | 无 -> 类型变量 (生成类型变量 ())
      | 有 绑定 ->
          匹配 获取符号类型 绑定 的
          | 变量符号 (类型名, _) ->
              匹配 查找变量类型 上下文.类型环境 名称 的
              | 有 类型 -> 类型
              | 无 -> 基础类型 类型名
          | 函数符号 (返回类型, 参数类型列表, _) ->
              (* 构造函数类型 *)
              let 参数类型 = 匹配 参数类型列表 的
                | [] -> 基础类型 "单元"
                | [单个类型] -> 基础类型 单个类型
                | 多个类型 -> 元组类型 (List.map (函数 类型名 -> 基础类型 类型名) 多个类型)
              在
              函数类型 (参数类型, 基础类型 返回类型)
          | _ -> 类型变量 (生成类型变量 ())
          
  | 二元运算表达式 (左表达式, 运算符, 右表达式, 位置) ->
      let 左类型 = 分析表达式 上下文 左表达式 在
      let 右类型 = 分析表达式 上下文 右表达式 在
      匹配 推导二元运算类型 运算符 左类型 右类型 的
      | 成功 结果类型 -> 结果类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 (类型错误 (信息, 位置));
          类型变量 (生成类型变量 ())
          
  | 一元运算表达式 (运算符, 表达式, 位置) ->
      let 表达式类型 = 分析表达式 上下文 表达式 在
      匹配 推导一元运算类型 运算符 表达式类型 的
      | 成功 结果类型 -> 结果类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 (类型错误 (信息, 位置));
          类型变量 (生成类型变量 ())
          
  | 条件表达式 (条件, 真分支, 假分支, 位置) ->
      let 条件类型 = 分析表达式 上下文 条件 在
      let 真分支类型 = 分析表达式 上下文 真分支 在
      let 假分支类型 = 分析表达式 上下文 假分支 在
      
      (* 检查条件是否为布尔类型 *)
      匹配 统一类型 上下文.类型环境 条件类型 (基础类型 "布尔值") 的
      | 错误 _ ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("条件表达式要求布尔类型", 位置))
      | 成功 () -> ();
      
      (* 统一两个分支的类型 *)
      匹配 统一类型 上下文.类型环境 真分支类型 假分支类型 的
      | 成功 () -> 真分支类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("条件表达式的分支类型不匹配: " ^ 信息, 位置));
          类型变量 (生成类型变量 ())
          
  | 让绑定表达式 (变量名, 值表达式, 体表达式, 位置) ->
      let 值类型 = 分析表达式 上下文 值表达式 在
      进入作用域 上下文.符号表;
      let 绑定成功 = 绑定符号 上下文.符号表 变量名 
        (变量符号 (格式化类型 值类型, 位置)) 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 变量名 值类型;
      let 体类型 = 分析表达式 上下文 体表达式 在
      退出作用域 上下文.符号表;
      体类型
      
  | 函数表达式 (参数列表, 体表达式, 位置) ->
      进入作用域 上下文.符号表;
      let 参数类型列表 = List.map (函数 参数名 ->
        let 参数类型 = 类型变量 (生成类型变量 ()) 在
        忽略 (绑定符号 上下文.符号表 参数名 
          (变量符号 (格式化类型 参数类型, 位置)) 位置 false);
        绑定变量类型 上下文.类型环境 参数名 参数类型;
        参数类型
      ) 参数列表 在
      
      let 体类型 = 分析表达式 上下文 体表达式 在
      退出作用域 上下文.符号表;
      
      let 参数类型 = 匹配 参数类型列表 的
        | [] -> 基础类型 "单元"
        | [单个类型] -> 单个类型
        | 多个类型 -> 元组类型 多个类型
      在
      函数类型 (参数类型, 体类型)
      
  | 函数调用表达式 (函数表达式, 参数列表, 位置) ->
      let 函数类型 = 分析表达式 上下文 函数表达式 在
      let 参数类型列表 = List.map (分析表达式 上下文) 参数列表 在
      
      let 参数类型 = 匹配 参数类型列表 的
        | [] -> 基础类型 "单元"
        | [单个类型] -> 单个类型
        | 多个类型 -> 元组类型 多个类型
      在
      
      let 返回类型 = 类型变量 (生成类型变量 ()) 在
      let 期望函数类型 = 函数类型 (参数类型, 返回类型) 在
      
      匹配 统一类型 上下文.类型环境 函数类型 期望函数类型 的
      | 成功 () -> 返回类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("函数调用类型错误: " ^ 信息, 位置));
          类型变量 (生成类型变量 ())
          
  | 列表表达式 (元素列表, 位置) ->
      匹配 元素列表 的
      | [] -> 列表类型 (类型变量 (生成类型变量 ()))
      | 第一个元素 :: 其余元素 ->
          let 第一个类型 = 分析表达式 上下文 第一个元素 在
          List.iter (函数 元素 ->
            let 元素类型 = 分析表达式 上下文 元素 在
            匹配 统一类型 上下文.类型环境 第一个类型 元素类型 的
            | 错误 信息 ->
                添加编译错误 上下文.错误收集器 
                  (类型错误 ("列表元素类型不一致: " ^ 信息, 位置))
            | 成功 () -> ()
          ) 其余元素;
          列表类型 第一个类型
          
  | 元组表达式 (元素列表, 位置) ->
      let 元素类型列表 = List.map (分析表达式 上下文) 元素列表 在
      元组类型 元素类型列表
      
  | 引用表达式 (内容表达式, 位置) ->
      let 内容类型 = 分析表达式 上下文 内容表达式 在
      引用类型 内容类型
      
  | 解引用表达式 (引用表达式, 位置) ->
      let 引用类型 = 分析表达式 上下文 引用表达式 在
      let 内容类型 = 类型变量 (生成类型变量 ()) 在
      let 期望引用类型 = 引用类型 内容类型 在
      匹配 统一类型 上下文.类型环境 引用类型 期望引用类型 的
      | 成功 () -> 内容类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("解引用要求引用类型: " ^ 信息, 位置));
          类型变量 (生成类型变量 ())
          
  | 数组表达式 (元素列表, 位置) ->
      匹配 元素列表 的
      | [] -> 数组类型 (类型变量 (生成类型变量 ()))
      | 第一个元素 :: 其余元素 ->
          let 第一个类型 = 分析表达式 上下文 第一个元素 在
          List.iter (函数 元素 ->
            let 元素类型 = 分析表达式 上下文 元素 在
            匹配 统一类型 上下文.类型环境 第一个类型 元素类型 的
            | 错误 信息 ->
                添加编译错误 上下文.错误收集器 
                  (类型错误 ("数组元素类型不一致: " ^ 信息, 位置))
            | 成功 () -> ()
          ) 其余元素;
          数组类型 第一个类型
          
  | 数组访问表达式 (数组表达式, 索引表达式, 位置) ->
      let 数组类型 = 分析表达式 上下文 数组表达式 在
      let 索引类型 = 分析表达式 上下文 索引表达式 在
      
      (* 检查索引是否为整数 *)
      匹配 统一类型 上下文.类型环境 索引类型 (基础类型 "整数") 的
      | 错误 _ ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("数组索引必须是整数", 位置))
      | 成功 () -> ();
      
      (* 提取数组元素类型 *)
      let 元素类型 = 类型变量 (生成类型变量 ()) 在
      let 期望数组类型 = 数组类型 元素类型 在
      匹配 统一类型 上下文.类型环境 数组类型 期望数组类型 的
      | 成功 () -> 元素类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("数组访问要求数组类型: " ^ 信息, 位置));
          类型变量 (生成类型变量 ())
          
  | _ ->
      (* 其他表达式类型的处理 *)
      添加编译错误 上下文.错误收集器 
        (语义错误 ("尚未实现的表达式类型", 表达式位置 表达式));
      类型变量 (生成类型变量 ())

(* 分析语句 *)
让 递归 分析语句 = 函数 上下文 语句 ->
  匹配 语句 的
  | 表达式语句 表达式 ->
      忽略 (分析表达式 上下文 表达式)
      
  | 让绑定语句 (变量名, 值表达式, 位置) ->
      let 值类型 = 分析表达式 上下文 值表达式 在
      let 绑定成功 = 绑定符号 上下文.符号表 变量名 
        (变量符号 (格式化类型 值类型, 位置)) 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 变量名 值类型
        
  | 递归让绑定语句 (函数名, 函数表达式, 位置) ->
      (* 先创建一个类型变量用于递归引用 *)
      let 函数类型变量 = 类型变量 (生成类型变量 ()) 在
      let 绑定成功 = 绑定符号 上下文.符号表 函数名 
        (函数符号 (格式化类型 函数类型变量, [], 位置)) 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 函数名 函数类型变量;
      
      (* 然后分析函数表达式 *)
      let 实际函数类型 = 分析表达式 上下文 函数表达式 在
      
      (* 统一类型变量和实际类型 *)
      匹配 统一类型 上下文.类型环境 函数类型变量 实际函数类型 的
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 
            (类型错误 ("递归函数类型不一致: " ^ 信息, 位置))
      | 成功 () -> ()
      
  | 类型定义语句 类型定义 ->
      分析类型定义 上下文 类型定义
      
  | 异常定义语句 (异常名, 类型选项, 位置) ->
      (* 简单处理异常定义 *)
      let 异常类型 = 匹配 类型选项 的
        | 无 -> 基础类型 "异常"
        | 有 类型表达式 -> 类型表达式到内部类型 上下文.类型环境 类型表达式
      在
      忽略 (绑定符号 上下文.符号表 异常名 
        (构造器符号 (异常名, 格式化类型 异常类型, 位置)) 位置 false)

和 分析类型定义 = 函数 上下文 类型定义 ->
  匹配 类型定义 的
  | 类型别名 (类型名, 类型表达式, 位置) ->
      let 内部类型 = 类型表达式到内部类型 上下文.类型环境 类型表达式 在
      字典添加 上下文.类型环境.类型定义 类型名 内部类型;
      忽略 (绑定符号 上下文.符号表 类型名 
        (类型符号 (类型名, 位置)) 位置 false)
        
  | 变体类型定义 (类型名, 构造器列表, 位置) ->
      (* 先绑定类型名 *)
      let 类型变量 = 类型变量 (生成类型变量 ()) 在
      字典添加 上下文.类型环境.类型定义 类型名 类型变量;
      忽略 (绑定符号 上下文.符号表 类型名 
        (类型符号 (类型名, 位置)) 位置 false);
      
      (* 然后绑定每个构造器 *)
      List.iter (函数 (构造器名, 参数类型列表) ->
        let 构造器类型 = 匹配 参数类型列表 的
          | [] -> 类型变量
          | 参数类型 ->
              let 参数内部类型列表 = List.map (类型表达式到内部类型 上下文.类型环境) 参数类型 在
              let 参数类型 = 匹配 参数内部类型列表 的
                | [单个类型] -> 单个类型
                | 多个类型 -> 元组类型 多个类型
                | [] -> 基础类型 "单元"
              在
              函数类型 (参数类型, 类型变量)
        在
        忽略 (绑定符号 上下文.符号表 构造器名 
          (构造器符号 (构造器名, 类型名, 位置)) 位置 false);
        绑定变量类型 上下文.类型环境 构造器名 构造器类型
      ) 构造器列表
      
  | 记录类型定义 (类型名, 字段列表, 位置) ->
      let 字段类型列表 = List.map (函数 (字段名, 类型表达式) ->
        (字段名, 类型表达式到内部类型 上下文.类型环境 类型表达式)
      ) 字段列表 在
      let 记录类型 = 记录类型 字段类型列表 在
      字典添加 上下文.类型环境.类型定义 类型名 记录类型;
      忽略 (绑定符号 上下文.符号表 类型名 
        (类型符号 (类型名, 位置)) 位置 false)

(* 分析程序 *)
让 分析程序 = 函数 上下文 程序 ->
  重置类型变量计数器 ();
  List.iter (分析语句 上下文) 程序

(* 主要的语义分析入口函数 *)
让 语义分析 = 函数 程序 文件名 ->
  let 错误收集器 = 创建错误收集器 () 在
  let 上下文 = 创建语义分析上下文 错误收集器 在
  分析程序 上下文 程序;
  
  (* 返回分析结果 *)
  if 有错误 错误收集器 then
    编译失败 (获取错误列表 错误收集器)
  else
    编译成功 ()
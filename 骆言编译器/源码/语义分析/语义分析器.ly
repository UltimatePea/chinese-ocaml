（*
 * 语义分析器 - 主要的语义分析入口
 * 整合符号表管理和类型检查功能
 *）

「：引入基础模块：」
使用 基础工具.工具库
使用 基础工具.位置信息
使用 基础工具.错误处理
使用 基础工具.抽象语法树
使用 语义分析.符号表
使用 语义分析.类型系统

「：语义分析上下文：」
类型 语义分析上下文={
  符号表: 符号表;
  类型环境: 类型环境;
  错误收集器: 错误收集器;
  当前函数返回类型: 内部类型 选项 参考;
  在循环中: 布尔值 参考;
}

「：创建语义分析上下文：」
夫「创建语义分析上下文」者受 错误收集器 焉算法乃
  设「符号表」为创建符号表 错误收集器 在
  设「类型环境」为创建类型环境 （） 在
  初始化全局符号 符号表;
  初始化基础类型环境 类型环境;
  {
    符号表=符号表;
    类型环境=类型环境;
    错误收集器=错误收集器;
    当前函数返回类型=参考 无;
    在循环中=参考 false;
  }
也

「：分析表达式并推导其类型：」
夫 递归 分析表达式 者 受 上下文 表达式 焉算法乃
  观「表达式」之性
  | 字面量表达式 （字面量, 位置） ->
      推导字面量类型 字面量

  | 变量表达式 （名称, 位置） ->
      观 查找符号或报错 上下文.符号表 名称 位置 之 性
      | 无 -> 类型变量 （生成类型变量 （））
      | 有 绑定 ->
          观 获取符号类型 绑定 之 性
          | 变量符号 （类型名, _） ->
              观 查找变量类型 上下文.类型环境 名称 之 性
              | 有 类型 -> 类型
              | 无 -> 基础类型 类型名
              观毕
          | 函数符号 （返回类型, 参数类型列表, _） ->
              「：构造函数类型：」
              设「参数类型」为观「参数类型列表」之性
                | 空空如也 -> 基础类型 『单元』
                | (列开始 单个类型 其一 列结束) -> 基础类型 单个类型
                | 多个类型 -> 元组类型 （List.map （夫 类型名 者 算法 乃 基础类型 类型名 也） 多个类型）
              观毕 在
              函数类型 （参数类型, 基础类型 返回类型）
          | _ -> 类型变量 （生成类型变量 （））
          观毕
      观毕

  | 二元运算表达式 （左表达式, 运算符, 右表达式, 位置） ->
      设「左类型」为分析表达式 上下文 左表达式 在
      设「右类型」为分析表达式 上下文 右表达式 在
      观 推导二元运算类型 运算符 左类型 右类型 之 性
      | 成功 结果类型 -> 结果类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 （类型错误 （信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | 一元运算表达式 （运算符, 表达式, 位置） ->
      设「表达式类型」为分析表达式 上下文 表达式 在
      观 推导一元运算类型 运算符 表达式类型 之 性
      | 成功 结果类型 -> 结果类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器 （类型错误 （信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | 条件表达式 （条件, 真分支, 假分支, 位置） ->
      设「条件类型」为分析表达式 上下文 条件 在
      设「真分支类型」为分析表达式 上下文 真分支 在
      设「假分支类型」为分析表达式 上下文 假分支 在

      「：检查条件是否为布尔类型：」
      观 统一类型 上下文.类型环境 条件类型 （基础类型 『布尔值』） 之 性
      | 错误 _ ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『条件表达式要求布尔类型』, 位置））
      | 成功 （） -> （）
      观毕;

      「：统一两个分支的类型：」
      观 统一类型 上下文.类型环境 真分支类型 假分支类型 之 性
      | 成功 （） -> 真分支类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『条件表达式的分支类型不匹配: 』 ^ 信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | 让绑定表达式 （变量名, 值表达式, 体表达式, 位置） ->
      设「值类型」为分析表达式 上下文 值表达式 在
      进入作用域 上下文.符号表;
      设「绑定成功」为绑定符号 上下文.符号表 变量名
        （变量符号 （格式化类型 值类型, 位置）） 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 变量名 值类型;
      设「体类型」为分析表达式 上下文 体表达式 在
      退出作用域 上下文.符号表;
      体类型

  | 函数表达式 （参数列表, 体表达式, 位置） ->
      进入作用域 上下文.符号表;
      设「参数类型列表」为List.map （夫 参数名 者 算法 乃
        设「参数类型」为类型变量 （生成类型变量 （）） 在
        忽略 （绑定符号 上下文.符号表 参数名
          （变量符号 （格式化类型 参数类型, 位置）） 位置 false）;
        绑定变量类型 上下文.类型环境 参数名 参数类型;
        参数类型
      也） 参数列表 在

      设「体类型」为分析表达式 上下文 体表达式 在
      退出作用域 上下文.符号表;

      设「参数类型」为观「参数类型列表」之性
        | 空空如也 -> 基础类型 『单元』
        | (列开始 单个类型 其一 列结束) -> 单个类型
        | 多个类型 -> 元组类型 多个类型
      观毕 在
      函数类型 （参数类型, 体类型）

  | 函数调用表达式 （函数表达式, 参数列表, 位置） ->
      设「函数类型」为分析表达式 上下文 函数表达式 在
      设「参数类型列表」为List.map （分析表达式 上下文） 参数列表 在

      设「参数类型」为观「参数类型列表」之性
        | 空空如也 -> 基础类型 『单元』
        | (列开始 单个类型 其一 列结束) -> 单个类型
        | 多个类型 -> 元组类型 多个类型
      观毕 在

      设「返回类型」为类型变量 （生成类型变量 （）） 在
      设「期望函数类型」为函数类型 （参数类型, 返回类型） 在

      观 统一类型 上下文.类型环境 函数类型 期望函数类型 之 性
      | 成功 （） -> 返回类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『函数调用类型错误: 』 ^ 信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | 列表表达式 （元素列表, 位置） ->
      观「元素列表」之性
      | 空空如也 -> 列表类型 （类型变量 （生成类型变量 （）））
      | 第一个元素 :: 其余元素 ->
          设「第一个类型」为分析表达式 上下文 第一个元素 在
          List.iter （夫 元素 者 算法 乃
            设「元素类型」为分析表达式 上下文 元素 在
            观 统一类型 上下文.类型环境 第一个类型 元素类型 之 性
            | 错误 信息 ->
                添加编译错误 上下文.错误收集器
                  （类型错误 （『列表元素类型不一致: 』 ^ 信息, 位置））
            | 成功 （） -> （）
            观毕
          也） 其余元素;
          列表类型 第一个类型
      观毕

  | 元组表达式 （元素列表, 位置） ->
      设「元素类型列表」为List.map （分析表达式 上下文） 元素列表 在
      元组类型 元素类型列表

  | 引用表达式 （内容表达式, 位置） ->
      设「内容类型」为分析表达式 上下文 内容表达式 在
      引用类型 内容类型

  | 解引用表达式 （引用表达式, 位置） ->
      设「引用类型」为分析表达式 上下文 引用表达式 在
      设「内容类型」为类型变量 （生成类型变量 （）） 在
      设「期望引用类型」为引用类型 内容类型 在
      观 统一类型 上下文.类型环境 引用类型 期望引用类型 之 性
      | 成功 （） -> 内容类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『解引用要求引用类型: 』 ^ 信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | 数组表达式 （元素列表, 位置） ->
      观「元素列表」之性
      | 空空如也 -> 数组类型 （类型变量 （生成类型变量 （）））
      | 第一个元素 :: 其余元素 ->
          设「第一个类型」为分析表达式 上下文 第一个元素 在
          List.iter （夫 元素 者 算法 乃
            设「元素类型」为分析表达式 上下文 元素 在
            观 统一类型 上下文.类型环境 第一个类型 元素类型 之 性
            | 错误 信息 ->
                添加编译错误 上下文.错误收集器
                  （类型错误 （『数组元素类型不一致: 』 ^ 信息, 位置））
            | 成功 （） -> （）
            观毕
          也） 其余元素;
          数组类型 第一个类型
      观毕

  | 数组访问表达式 （数组表达式, 索引表达式, 位置） ->
      设「数组类型」为分析表达式 上下文 数组表达式 在
      设「索引类型」为分析表达式 上下文 索引表达式 在

      「：检查索引是否为整数：」
      观 统一类型 上下文.类型环境 索引类型 （基础类型 『整数』） 之 性
      | 错误 _ ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『数组索引必须是整数』, 位置））
      | 成功 （） -> （）
      观毕;

      「：提取数组元素类型：」
      设「元素类型」为类型变量 （生成类型变量 （）） 在
      设「期望数组类型」为数组类型 元素类型 在
      观 统一类型 上下文.类型环境 数组类型 期望数组类型 之 性
      | 成功 （） -> 元素类型
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『数组访问要求数组类型: 』 ^ 信息, 位置））;
          类型变量 （生成类型变量 （））
      观毕

  | _ ->
      「：其他表达式类型的处理：」
      添加编译错误 上下文.错误收集器
        （语义错误 （『尚未实现的表达式类型』, 表达式位置 表达式））;
      类型变量 （生成类型变量 （））
  观毕
也

「：分析语句：」
夫 递归 分析语句 者 受 上下文 语句 焉算法乃
  观「语句」之性
  | 表达式语句 表达式 ->
      忽略 （分析表达式 上下文 表达式）

  | 让绑定语句 （变量名, 值表达式, 位置） ->
      设「值类型」为分析表达式 上下文 值表达式 在
      设「绑定成功」为绑定符号 上下文.符号表 变量名
        （变量符号 （格式化类型 值类型, 位置）） 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 变量名 值类型

  | 递归让绑定语句 （函数名, 函数表达式, 位置） ->
      「：先创建一个类型变量用于递归引用：」
      设「函数类型变量」为类型变量 （生成类型变量 （）） 在
      设「绑定成功」为绑定符号 上下文.符号表 函数名
        （函数符号 （格式化类型 函数类型变量, 空空如也, 位置）） 位置 false 在
      if 绑定成功 then
        绑定变量类型 上下文.类型环境 函数名 函数类型变量;

      「：然后分析函数表达式：」
      设「实际函数类型」为分析表达式 上下文 函数表达式 在

      「：统一类型变量和实际类型：」
      观 统一类型 上下文.类型环境 函数类型变量 实际函数类型 之 性
      | 错误 信息 ->
          添加编译错误 上下文.错误收集器
            （类型错误 （『递归函数类型不一致: 』 ^ 信息, 位置））
      | 成功 （） -> （）
      观毕

  | 类型定义语句 类型定义 ->
      分析类型定义 上下文 类型定义

  | 异常定义语句 （异常名, 类型选项, 位置） ->
      「：简单处理异常定义：」
      设「异常类型」为观「类型选项」之性
        | 无 -> 基础类型 『异常』
        | 有 类型表达式 -> 类型表达式到内部类型 上下文.类型环境 类型表达式
      观毕 在
      忽略 （绑定符号 上下文.符号表 异常名
        （构造器符号 （异常名, 格式化类型 异常类型, 位置）） 位置 false）
  观毕
也

和 夫「分析类型定义」者受 上下文 类型定义 焉算法乃
  观「类型定义」之性
  | 类型别名 （类型名, 类型表达式, 位置） ->
      设「内部类型」为类型表达式到内部类型 上下文.类型环境 类型表达式 在
      字典添加 上下文.类型环境.类型定义 类型名 内部类型;
      忽略 （绑定符号 上下文.符号表 类型名
        （类型符号 （类型名, 位置）） 位置 false）

  | 变体类型定义 （类型名, 构造器列表, 位置） ->
      「：先绑定类型名：」
      设「类型变量」为类型变量 （生成类型变量 （）） 在
      字典添加 上下文.类型环境.类型定义 类型名 类型变量;
      忽略 （绑定符号 上下文.符号表 类型名
        （类型符号 （类型名, 位置）） 位置 false）;

      「：然后绑定每个构造器：」
      List.iter （夫 （构造器名, 参数类型列表） 者 算法 乃
        设「构造器类型」为观「参数类型列表」之性
          | 空空如也 -> 类型变量
          | 参数类型 ->
              设「参数内部类型列表」为List.map （类型表达式到内部类型 上下文.类型环境） 参数类型 在
              设「参数类型」为观「参数内部类型列表」之性
                | (列开始 单个类型 其一 列结束) -> 单个类型
                | 多个类型 -> 元组类型 多个类型
                | 空空如也 -> 基础类型 『单元』
              观毕 在
              函数类型 （参数类型, 类型变量）
        观毕 在
        忽略 （绑定符号 上下文.符号表 构造器名
          （构造器符号 （构造器名, 类型名, 位置）） 位置 false）;
        绑定变量类型 上下文.类型环境 构造器名 构造器类型
      也） 构造器列表

  | 记录类型定义 （类型名, 字段列表, 位置） ->
      设「字段类型列表」为List.map （夫 （字段名, 类型表达式） 者 算法 乃
        （字段名, 类型表达式到内部类型 上下文.类型环境 类型表达式）
      也） 字段列表 在
      设「记录类型」为记录类型 字段类型列表 在
      字典添加 上下文.类型环境.类型定义 类型名 记录类型;
      忽略 （绑定符号 上下文.符号表 类型名
        （类型符号 （类型名, 位置）） 位置 false）
  观毕
也

「：分析程序：」
夫「分析程序」者受 上下文 程序 焉算法乃
  重置类型变量计数器 （）;
  List.iter （分析语句 上下文） 程序
也

「：主要的语义分析入口函数：」
夫「语义分析」者受 程序 文件名 焉算法乃
  设「错误收集器」为创建错误收集器 （） 在
  设「上下文」为创建语义分析上下文 错误收集器 在
  分析程序 上下文 程序;

  「：返回分析结果：」
  if 有错误 错误收集器 then
    编译失败 （获取错误列表 错误收集器）
  else
    编译成功 （）
也
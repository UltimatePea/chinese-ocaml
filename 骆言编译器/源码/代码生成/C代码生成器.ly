（*
 * C代码生成器
 * 将骆言抽象语法树转换为C代码
 *）

「：引入依赖模块：」
使用 抽象语法树
使用 工具库
使用 错误处理

「：代码生成配置：」
类型 代码生成配置={
  输出文件: 字符串;
  包含调试信息: 布尔值;
  优化级别: 整数;
  运行时路径: 字符串;
}

「：代码生成上下文：」
类型 代码生成上下文={
  配置: 代码生成配置;
  可变 下一个变量ID: 整数;
  可变 下一个标签ID: 整数;
  可变 包含文件: 字符串 列表;
  可变 全局变量: 字符串 列表;
  可变 函数定义: 字符串 列表;
}

「：创建代码生成上下文：」
夫「创建上下文」者受 配置 焉算法乃 {
  配置=配置;
  下一个变量ID=0;
  下一个标签ID=0;
  包含文件=(列开始 『luoyan_runtime.h』 其一 列结束);
  全局变量=空空如也;
  函数定义=空空如也;
} 是谓

「：生成唯一变量名：」
夫「生成变量名」者受 上下文 前缀 焉算法乃
  设「id」为上下文.下一个变量ID 在
  上下文.下一个变量ID :=id + 1;
  『luoyan_var_』 ^ 前缀 ^ 『_』 ^ （字符串_从_整数 id） 是谓

「：生成唯一标签名：」
夫「生成标签名」者受 上下文 前缀 焉算法乃
  设「id」为上下文.下一个标签ID 在
  上下文.下一个标签ID :=id + 1;
  『luoyan_label_』 ^ 前缀 ^ 『_』 ^ （字符串_从_整数 id） 是谓

「：转义标识符名称：」
夫「转义标识符」者受 名称 焉算法乃
  设 递归 转义字符为函数 字符列表 结果 ->
    观「字符列表」之性
    | 空空如也 -> 反向 结果
    | 字符 :: 剩余 ->
      若 （字符 >='0' && 字符 <='9'） ||
         （字符 >='a' && 字符 <='z'） ||
         （字符 >='A' && 字符 <='Z'） ||
         字符='_'
      则 答 转义字符 剩余 （字符 :: 结果）
      余者答
        设「代码」为字符_到_整数 字符 在
        设「转义字符串」为『_』 ^ （十六进制_从_整数 代码） ^ 『_』 在
        转义字符 剩余 （（字符串_到_字符列表 转义字符串） @ 结果） 观毕
  在
  字符串_从_字符列表 （转义字符 （字符串_到_字符列表 名称） 空空如也） 是谓

「：生成C类型名：」
夫「骆言类型_到_C类型」者受 类型 焉算法乃
  观「类型」之性
  | 『整数』 -> 『luoyan_int_t』
  | 『浮点数』 -> 『luoyan_float_t』
  | 『字符串』 -> 『luoyan_string_t*』
  | 『布尔值』 -> 『luoyan_bool_t』
  | 『单元』 -> 『void』
  | 『列表』 -> 『luoyan_list_t*』
  | 『函数』 -> 『luoyan_function_t*』
  | 『记录』 -> 『luoyan_record_t*』
  | 『数组』 -> 『luoyan_array_t*』
  | 『引用』 -> 『luoyan_ref_t*』
  | _ -> 『luoyan_value_t*』 观毕是谓

「：生成表达式代码：」
设 递归 生成表达式为函数 上下文 表达式 ->
  观「表达式」之性
  | 字面量表达式 （字面量, _） -> 生成字面量 字面量
  | 变量表达式 （名称, _） ->
    设「转义名称」为转义标识符 名称 在
    『luoyan_env_lookup（env, \』『 ^ 转义名称 ^ 』\『）』
  | 二元运算表达式 （左表达式, 运算符, 右表达式, _） ->
    生成二元运算 上下文 运算符 左表达式 右表达式
  | 一元运算表达式 （运算符, 表达式, _） ->
    生成一元运算 上下文 运算符 表达式
  | 条件表达式 （条件, 那么分支, 否则分支, _） ->
    生成条件表达式 上下文 条件 那么分支 否则分支
  | 让绑定表达式 （变量, 值表达式, 主体表达式, _） ->
    生成让绑定表达式 上下文 变量 值表达式 主体表达式
  | 函数表达式 （参数列表, 主体, _） ->
    生成函数表达式 上下文 参数列表 主体
  | 函数调用表达式 （函数表达式, 参数表达式列表, _） ->
    生成调用表达式 上下文 函数表达式 参数表达式列表
  | 模式匹配表达式 （表达式, 模式列表, _） ->
    生成匹配表达式 上下文 表达式 模式列表
  | 列表表达式 （表达式列表, _） ->
    生成列表表达式 上下文 表达式列表
  | 元组表达式 （表达式列表, _） ->
    生成元组表达式 上下文 表达式列表
  | 记录表达式 （字段列表, _） ->
    生成记录表达式 上下文 字段列表
  | 字段访问表达式 （记录表达式, 字段名, _） ->
    生成字段访问表达式 上下文 记录表达式 字段名
  | 记录更新表达式 （记录表达式, 更新列表, _） ->
    生成记录更新表达式 上下文 记录表达式 更新列表
  | 数组表达式 （表达式列表, _） ->
    生成数组表达式 上下文 表达式列表
  | 数组访问表达式 （数组表达式, 索引表达式, _） ->
    生成数组访问表达式 上下文 数组表达式 索引表达式
  | 数组更新表达式 （数组表达式, 索引表达式, 值表达式, _） ->
    生成数组更新表达式 上下文 数组表达式 索引表达式 值表达式
  | 引用表达式 （表达式, _） ->
    生成引用表达式 上下文 表达式
  | 解引用表达式 （表达式, _） ->
    生成解引用表达式 上下文 表达式
  | 赋值表达式 （引用表达式, 值表达式, _） ->
    生成赋值表达式 上下文 引用表达式 值表达式
  | 构造器表达式 （构造器名, 参数列表, _） ->
    生成构造器表达式 上下文 构造器名 参数列表
  | 序列表达式 （表达式列表, _） ->
    生成序列表达式 上下文 表达式列表
  | _ -> 错误 『不支持的表达式类型』 观毕

「：生成字面量代码：」
夫「生成字面量」者受 字面量 焉算法乃
  观「字面量」之性
  | 整数字面量 i -> 『luoyan_int（』 ^ （字符串_从_整数 i） ^ 『L）』
  | 浮点字面量 f -> 『luoyan_float（』 ^ （字符串_从_浮点数 f） ^ 『）』
  | 字符串字面量 s ->
    设「转义字符串」为为C转义字符串 s 在
    『luoyan_string（\』『 ^ 转义字符串 ^ 』\『）』
  | 布尔字面量 b ->
    『luoyan_bool（』 ^ （若 b 则 答 『true』 余者答 『false』） ^ 『）』
  | 单元字面量 -> 『luoyan_unit（）』 观毕是谓

「：为C转义字符串：」
夫「为C转义字符串」者受 字符串 焉算法乃
  设 递归 转义字符为函数 字符列表 结果 ->
    观「字符列表」之性
    | 空空如也 -> 反向 结果
    | '『' :: 剩余 -> 转义字符 剩余 （'』' :: '\\' :: 结果）
    | '\\' :: 剩余 -> 转义字符 剩余 （'\\' :: '\\' :: 结果）
    | '\n' :: 剩余 -> 转义字符 剩余 （'n' :: '\\' :: 结果）
    | '\t' :: 剩余 -> 转义字符 剩余 （'t' :: '\\' :: 结果）
    | '\r' :: 剩余 -> 转义字符 剩余 （'r' :: '\\' :: 结果）
    | 字符 :: 剩余 -> 转义字符 剩余 （字符 :: 结果） 观毕
  在
  字符串_从_字符列表 （转义字符 （字符串_到_字符列表 字符串） 空空如也） 是谓

「：生成二元运算代码：」
夫「生成二元运算」者受 上下文 运算符 左表达式 右表达式 焉算法乃
  设「左代码」为生成表达式 上下文 左表达式 在
  设「右代码」为生成表达式 上下文 右表达式 在
  观「运算符」之性
  | 加法 -> 『luoyan_add（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 减法 -> 『luoyan_subtract（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 乘法 -> 『luoyan_multiply（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 除法 -> 『luoyan_divide（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 模运算 -> 『luoyan_modulo（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 等于 -> 『luoyan_equal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 不等于 -> 『luoyan_not_equal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 小于 -> 『luoyan_less_than（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 小于等于 -> 『luoyan_less_equal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 大于 -> 『luoyan_greater_than（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 大于等于 -> 『luoyan_greater_equal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 逻辑与 -> 『luoyan_logical_and（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 逻辑或 -> 『luoyan_logical_or（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 字符串连接 -> 『luoyan_string_concat（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』 观毕是谓

「：生成一元运算代码：」
夫「生成一元运算」者受 上下文 运算符 表达式 焉算法乃
  设「操作数代码」为生成表达式 上下文 表达式 在
  观「运算符」之性
  | 逻辑非 -> 『luoyan_logical_not（』 ^ 操作数代码 ^ 『）』
  | 数值取反 -> 『luoyan_subtract（luoyan_int（0）, 』 ^ 操作数代码 ^ 『）』 观毕是谓

「：生成条件表达式代码：」
夫「生成条件表达式」者受 上下文 条件 那么分支 否则分支 焉算法乃
  设「条件变量」为生成变量名 上下文 『cond』 在
  设「条件代码」为生成表达式 上下文 条件 在
  设「那么代码」为生成表达式 上下文 那么分支 在
  设「否则代码」为生成表达式 上下文 否则分支 在
  『（{ luoyan_value_t* 』 ^ 条件变量 ^ 『=』 ^ 条件代码 ^ 『; 』 ^
  『（（』 ^ 条件变量 ^ 『->type==LUOYAN_BOOL && 』 ^ 条件变量 ^ 『->data.bool_val）） ? （』 ^
  那么代码 ^ 『） : （』 ^ 否则代码 ^ 『）; }）』 是谓

「：生成让绑定表达式代码：」
夫「生成让绑定表达式」者受 上下文 变量 值表达式 主体表达式 焉算法乃
  设「值代码」为生成表达式 上下文 值表达式 在
  设「转义变量」为转义标识符 变量 在
  设「主体代码」为生成表达式 上下文 主体表达式 在
  『（{ luoyan_env_bind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 值代码 ^ 『）; 』 ^ 主体代码 ^ 『; }）』 是谓

「：生成函数表达式代码：」
夫「生成函数表达式」者受 上下文 参数列表 主体 焉算法乃
  设「函数名」为生成变量名 上下文 『func』 在
  设「主体代码」为生成表达式 上下文 主体 在

  「：为多参数函数创建curry化的函数：」
  设 递归 创建curry化函数为（函数 剩余参数 主体代码 ->
    匹配 剩余参数 与
    | 空空如也 -> 主体代码
    | 参数 :: 其他参数 ->
      设「转义参数」为转义标识符 参数 在
      设「内部主体」为创建curry化函数 其他参数 主体代码 在
      如果 其他参数=空空如也
      那么
        「：最后一个参数，直接返回主体：」
        设「函数实现」为          『luoyan_value_t* 』 ^ 函数名 ^ 『_impl_』 ^ 参数 ^ 『（luoyan_env_t* env, luoyan_value_t* arg） {\n』 ^
          『  luoyan_env_bind（env, \』『 ^ 转义参数 ^ 』\『, arg）;\n』 ^
          『  return 』 ^ 内部主体 ^ 『;\n』 ^
          『}』 在
        上下文.函数定义 :=函数实现 :: 上下文.函数定义;
        函数实现
      否则
        「：还有更多参数，返回另一个函数：」
        设「下一个函数名」为生成变量名 上下文 『func』 在
        设「函数实现」为          『luoyan_value_t* 』 ^ 函数名 ^ 『_impl_』 ^ 参数 ^ 『（luoyan_env_t* env, luoyan_value_t* arg） {\n』 ^
          『  luoyan_env_bind（env, \』『 ^ 转义参数 ^ 』\『, arg）;\n』 ^
          『  return luoyan_function_create（』 ^ 下一个函数名 ^ 『_impl_』 ^ （列表_头部 其他参数） ^ 『, env, \』『 ^ 下一个函数名 ^ 』\『）;\n』 ^
          『}』 在
        上下文.函数定义 :=函数实现 :: 上下文.函数定义;
        函数实现） 在

  设「_」为创建curry化函数 参数列表 主体代码 在

  匹配 参数列表 与
  | 空空如也 -> 『luoyan_unit（）』
  | 第一个参数 :: _ ->
    『luoyan_function_create（』 ^ 函数名 ^ 『_impl_』 ^ 第一个参数 ^ 『, env, \』『 ^ 函数名 ^ 』\『）』 观毕是谓

「：生成函数调用代码：」
夫「生成调用表达式」者受 上下文 函数表达式 参数表达式列表 焉算法乃
  设「函数代码」为生成表达式 上下文 函数表达式 在
  匹配 参数表达式列表 与
  | 空空如也 -> 函数代码  「：无参数调用：」
  | (列开始 参数表达式 其一 列结束) ->
    设「参数代码」为生成表达式 上下文 参数表达式 在
    『luoyan_function_call（』 ^ 函数代码 ^ 『, 』 ^ 参数代码 ^ 『）』
  | _ ->
    「：多参数调用：连续调用curry化的函数：」
    列表_折叠_左 （函数 累积函数 参数表达式 ->
      设「参数代码」为生成表达式 上下文 参数表达式 在
      『luoyan_function_call（』 ^ 累积函数 ^ 『, 』 ^ 参数代码 ^ 『）』
    ） 函数代码 参数表达式列表 观毕是谓

「：生成模式匹配表达式代码：」
夫「生成匹配表达式」者受 上下文 表达式 模式列表 焉算法乃
  设「表达式变量」为生成变量名 上下文 『match_expr』 在
  设「表达式代码」为生成表达式 上下文 表达式 在

  设 递归 生成模式列表为（函数 模式列表 ->
    匹配 模式列表 与
    | 空空如也 -> 『luoyan_unit（）』 「：应该不会到达这里：」
    | （模式, 表达式） :: 剩余 ->
      设「模式检查」为生成模式检查 上下文 表达式变量 模式 在
      设「表达式代码」为生成表达式 上下文 表达式 在
      如果 剩余=空空如也
      那么 『（』 ^ 模式检查 ^ 『） ? （』 ^ 表达式代码 ^ 『） : （luoyan_unit（））』
      否则 『（』 ^ 模式检查 ^ 『） ? （』 ^ 表达式代码 ^ 『） : （』 ^ （生成模式列表 剩余） ^ 『）』） 在

  『（{ luoyan_value_t* 』 ^ 表达式变量 ^ 『=』 ^ 表达式代码 ^ 『; 』 ^ （生成模式列表 模式列表） ^ 『; }）』 是谓

「：生成模式检查代码：」
夫「生成模式检查」者受 上下文 表达式变量 模式 焉算法乃
  匹配 模式 与
  | 字面量模式 （整数字面量 i, _） ->
    『luoyan_equals（』 ^ 表达式变量 ^ 『, luoyan_int（』 ^ （字符串_从_整数 i） ^ 『））』
  | 字面量模式 （字符串字面量 s, _） ->
    『luoyan_equals（』 ^ 表达式变量 ^ 『, luoyan_string（\』『 ^ （为C转义字符串 s） ^ 』\『））』
  | 字面量模式 （布尔字面量 b, _） ->
    『luoyan_equals（』 ^ 表达式变量 ^ 『, luoyan_bool（』 ^ （如果 b 那么 『true』 否则 『false』） ^ 『））』
  | 字面量模式 （单元字面量, _） ->
    『luoyan_equals（』 ^ 表达式变量 ^ 『, luoyan_unit（））』
  | 字面量模式 （浮点字面量 f, _） ->
    『luoyan_equals（』 ^ 表达式变量 ^ 『, luoyan_float（』 ^ （字符串_从_浮点数 f） ^ 『））』
  | 变量模式 （变量, _） ->
    设「转义变量」为转义标识符 变量 在
    『（luoyan_env_bind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式变量 ^ 『）, true）』
  | 空列表模式 _ ->
    『luoyan_list_is_empty（』 ^ 表达式变量 ^ 『）->data.bool_val』
  | 列表头尾模式 （头模式, 尾模式, _） ->
    设「头检查」为生成模式检查 上下文 （『luoyan_list_head（』 ^ 表达式变量 ^ 『）』） 头模式 在
    设「尾检查」为生成模式检查 上下文 （『luoyan_list_tail（』 ^ 表达式变量 ^ 『）』） 尾模式 在
    『（!luoyan_list_is_empty（』 ^ 表达式变量 ^ 『）->data.bool_val && 』 ^ 头检查 ^ 『 && 』 ^ 尾检查 ^ 『）』
  | 通配符模式 _ -> 『true』
  | _ -> 错误 『不支持的模式类型』 观毕是谓

「：生成列表表达式代码：」
夫「生成列表表达式」者受 上下文 表达式列表 焉算法乃
  设 递归 构建列表为（函数 表达式列表 ->
    观「表达式列表」之性
    | 空空如也 -> 『luoyan_list_empty（）』
    | 表达式 :: 剩余 ->
      设「元素代码」为生成表达式 上下文 表达式 在
      设「剩余代码」为构建列表 剩余 在
      『luoyan_list_cons（』 ^ 元素代码 ^ 『, 』 ^ 剩余代码 ^ 『）』 观毕） 在
  构建列表 表达式列表 是谓

「：生成元组表达式代码：」
夫「生成元组表达式」者受 上下文 表达式列表 焉算法乃
  观「表达式列表」之性
  | 空空如也 -> 『luoyan_unit（）』
  | (列开始 单个 其一 列结束) -> 生成表达式 上下文 单个
  | _ ->
    「：元组存储为记录，字段名为_0, _1, _2等：」
    设「元组变量」为生成变量名 上下文 『tuple』 在
    设「初始化代码」为『luoyan_record_create（）』 在
    设「字段赋值」为列表_映射_索引 （函数 i 表达式 ->
      设「字段名」为『_』 ^ （字符串_从_整数 i） 在
      设「字段代码」为生成表达式 上下文 表达式 在
      『luoyan_record_set_field（』 ^ 元组变量 ^ 『, \』『 ^ 字段名 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 表达式列表 在
    设「赋值代码」为字符串_连接 『; 』 字段赋值 在
    『（{ luoyan_value_t* 』 ^ 元组变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 元组变量 ^ 『; }）』 观毕是谓

「：生成记录表达式代码：」
夫「生成记录表达式」者受 上下文 字段列表 焉算法乃
  设「记录变量」为生成变量名 上下文 『record』 在
  设「初始化代码」为『luoyan_record_create（）』 在
  匹配 字段列表 与
  | 空空如也 -> 初始化代码
  | _ ->
    设「字段赋值」为列表_映射 （函数 （字段名, 字段表达式） ->
      设「字段代码」为生成表达式 上下文 字段表达式 在
      设「转义字段」为转义标识符 字段名 在
      『luoyan_record_set_field（』 ^ 记录变量 ^ 『, \』『 ^ 转义字段 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 字段列表 在
    设「赋值代码」为字符串_连接 『; 』 字段赋值 在
    『（{ luoyan_value_t* 』 ^ 记录变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 记录变量 ^ 『; }）』 观毕是谓

「：生成字段访问表达式代码：」
夫「生成字段访问表达式」者受 上下文 记录表达式 字段名 焉算法乃
  设「记录代码」为生成表达式 上下文 记录表达式 在
  设「转义字段」为转义标识符 字段名 在
  『luoyan_record_get_field（』 ^ 记录代码 ^ 『, \』『 ^ 转义字段 ^ 』\『）』 是谓

「：生成记录更新表达式代码：」
夫「生成记录更新表达式」者受 上下文 记录表达式 更新列表 焉算法乃
  设「记录代码」为生成表达式 上下文 记录表达式 在
  匹配 更新列表 与
  | 空空如也 -> 记录代码
  | （字段名, 字段表达式） :: 剩余 ->
    设「字段代码」为生成表达式 上下文 字段表达式 在
    设「转义字段」为转义标识符 字段名 在
    设「第一次更新」为『luoyan_record_update（』 ^ 记录代码 ^ 『, \』『 ^ 转义字段 ^ 』\『, 』 ^ 字段代码 ^ 『）』 在
    列表_折叠_左 （函数 累积代码 （字段名, 字段表达式） ->
      设「字段代码」为生成表达式 上下文 字段表达式 在
      设「转义字段名」为转义标识符 字段名 在
      『luoyan_record_update（』 ^ 累积代码 ^ 『, \』『 ^ 转义字段名 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 第一次更新 剩余 观毕是谓

「：生成数组表达式代码：」
夫「生成数组表达式」者受 上下文 表达式列表 焉算法乃
  匹配 表达式列表 与
  | 空空如也 -> 『luoyan_array_empty（）』
  | _ ->
    设「数组变量」为生成变量名 上下文 『array』 在
    设「初始化代码」为『luoyan_array_create（』 ^ （字符串_从_整数 （列表_长度 表达式列表）） ^ 『）』 在
    设「元素赋值」为列表_映射_索引 （函数 i 表达式 ->
      设「元素代码」为生成表达式 上下文 表达式 在
      『luoyan_array_set（』 ^ 数组变量 ^ 『, 』 ^ （字符串_从_整数 i） ^ 『, 』 ^ 元素代码 ^ 『）』
    ） 表达式列表 在
    设「赋值代码」为字符串_连接 『; 』 元素赋值 在
    『（{ luoyan_value_t* 』 ^ 数组变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 数组变量 ^ 『; }）』 观毕是谓

「：生成数组访问表达式代码：」
夫「生成数组访问表达式」者受 上下文 数组表达式 索引表达式 焉算法乃
  设「数组代码」为生成表达式 上下文 数组表达式 在
  设「索引代码」为生成表达式 上下文 索引表达式 在
  『luoyan_array_get（』 ^ 数组代码 ^ 『, 』 ^ 索引代码 ^ 『）』 是谓

「：生成数组更新表达式代码：」
夫「生成数组更新表达式」者受 上下文 数组表达式 索引表达式 值表达式 焉算法乃
  设「数组代码」为生成表达式 上下文 数组表达式 在
  设「索引代码」为生成表达式 上下文 索引表达式 在
  设「值代码」为生成表达式 上下文 值表达式 在
  『luoyan_array_update（』 ^ 数组代码 ^ 『, 』 ^ 索引代码 ^ 『, 』 ^ 值代码 ^ 『）』 是谓

「：生成引用表达式代码：」
夫「生成引用表达式」者受 上下文 表达式 焉算法乃
  设「值代码」为生成表达式 上下文 表达式 在
  『luoyan_ref_create（』 ^ 值代码 ^ 『）』 是谓

「：生成解引用表达式代码：」
夫「生成解引用表达式」者受 上下文 表达式 焉算法乃
  设「引用代码」为生成表达式 上下文 表达式 在
  『luoyan_ref_get（』 ^ 引用代码 ^ 『）』 是谓

「：生成赋值表达式代码：」
夫「生成赋值表达式」者受 上下文 引用表达式 值表达式 焉算法乃
  设「引用代码」为生成表达式 上下文 引用表达式 在
  设「值代码」为生成表达式 上下文 值表达式 在
  『luoyan_ref_set（』 ^ 引用代码 ^ 『, 』 ^ 值代码 ^ 『）』 是谓

「：生成构造器表达式代码：」
夫「生成构造器表达式」者受 上下文 构造器名 参数列表 焉算法乃
  设「构造器名称」为转义标识符 构造器名 在
  匹配 参数列表 与
  | 空空如也 ->
    「：无参数构造器，创建一个带有构造器名的记录：」
    『luoyan_constructor_create（\』『 ^ 构造器名称 ^ 』\『, NULL）』
  | _ ->
    设「参数代码」为列表_映射 （生成表达式 上下文） 参数列表 在
    设「参数数组」为字符串_连接 『, 』 参数代码 在
    『luoyan_constructor_create（\』『 ^ 构造器名称 ^ 』\『, luoyan_array_from_values（』 ^ 参数数组 ^ 『））』 观毕是谓

「：生成序列表达式代码：」
夫「生成序列表达式」者受 上下文 表达式列表 焉算法乃
  匹配 表达式列表 与
  | 空空如也 -> 『luoyan_unit（）』
  | (列开始 表达式 其一 列结束) -> 生成表达式 上下文 表达式
  | _ ->
    设「表达式代码列表」为列表_映射 （生成表达式 上下文） 表达式列表 在
    设「最后一个」为列表_最后一个 表达式代码列表 在
    设「前面的」为列表_去掉最后一个 表达式代码列表 在
    『（{ 』 ^ （字符串_连接 『; 』 前面的） ^ 『; 』 ^ 最后一个 ^ 『; }）』 观毕是谓

「：生成语句代码：」
夫「生成语句」者受 上下文 语句 焉算法乃
  观「语句」之性
  | 表达式语句 表达式 ->
    设「表达式代码」为生成表达式 上下文 表达式 在
    表达式代码 ^ 『;』
  | 设绑定语句 （变量, 表达式, _） ->
    设「表达式代码」为生成表达式 上下文 表达式 在
    设「转义变量」为转义标识符 变量 在
    『luoyan_env_bind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式代码 ^ 『）;』
  | 递归设绑定语句 （变量, 表达式, _） ->
    「：递归函数需要特殊处理：」
    设「转义变量」为转义标识符 变量 在
    设「表达式代码」为生成表达式 上下文 表达式 在
    『luoyan_env_bind（env, \』『 ^ 转义变量 ^ 』\『, luoyan_unit（））; 』 ^
    『luoyan_env_bind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式代码 ^ 『）;』
  | 类型定义语句 _ -> 『/* 类型定义在C生成中被忽略 */』
  | 异常定义语句 （_, _, _） -> 『/* 异常定义在C生成中被忽略 */』 观毕是谓

「：生成程序代码：」
夫「生成程序」者受 上下文 程序 焉算法乃
  设 递归 生成语句列表为（函数 语句列表 ->
    观「语句列表」之性
    | 空空如也 -> 『』
    | 语句 :: 剩余 ->
      设「语句代码」为生成语句 上下文 语句 在
      语句代码 ^ 『\n』 ^ （生成语句列表 剩余） 观毕） 在
  生成语句列表 程序 是谓

「：生成完整的C代码：」
夫「生成C代码」者受 配置 程序 焉算法乃
  设「上下文」为创建上下文 配置 在

  「：生成主要代码：」
  设「主代码」为生成程序 上下文 程序 在

  「：生成完整的C文件：」
  设「包含文件」为字符串_连接 『\n』 （列表_映射 （函数 文件 -> 『#include \』『 ^ 文件 ^ 』\『』） 上下文.包含文件） 在
  设「函数定义」为字符串_连接 『\n\n』 （反向 上下文.函数定义） 在

  设「转义打印」为转义标识符 『打印』 在
  设「转义读取」为转义标识符 『读取』 在
  设「转义读取文件」为转义标识符 『内置_读取文件』 在
  设「转义写入文件」为转义标识符 『内置_写入文件』 在
  设「转义文件存在」为转义标识符 『内置_文件存在』 在
  设「转义系统参数」为转义标识符 『系统_参数列表』 在
  设「转义系统退出」为转义标识符 『系统_退出』 在
  设「转义字符串长度」为转义标识符 『内置_字符串长度』 在
  设「转义字符串连接」为转义标识符 『内置_字符串连接』 在
  设「转义整数转字符串」为转义标识符 『字符串_从_整数』 在
  设「转义字符串转整数」为转义标识符 『整数_从_字符串』 在
  包含文件 ^ 『\n\n』 ^
  函数定义 ^ 『\n\n』 ^
  『int main（int argc, char** argv） {\n』 ^
  『  luoyan_runtime_init（）;\n』 ^
  『  luoyan_set_system_args（argc, argv）;\n』 ^
  『  luoyan_env_t* env=luoyan_env_create（NULL）;\n』 ^
  『  \n』 ^
  『  // 添加内置函数\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义打印 ^ 』\『, luoyan_function_create（luoyan_builtin_print, env, \』打印\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义读取 ^ 』\『, luoyan_function_create（luoyan_builtin_read, env, \』读取\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义读取文件 ^ 』\『, luoyan_function_create（luoyan_builtin_read_file, env, \』内置_读取文件\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义写入文件 ^ 』\『, luoyan_function_create（luoyan_builtin_write_file, env, \』内置_写入文件\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义文件存在 ^ 』\『, luoyan_function_create（luoyan_builtin_file_exists, env, \』内置_文件存在\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义系统参数 ^ 』\『, luoyan_function_create（luoyan_builtin_system_args, env, \』系统_参数列表\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义系统退出 ^ 』\『, luoyan_function_create（luoyan_builtin_system_exit, env, \』系统_退出\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义字符串长度 ^ 』\『, luoyan_function_create（luoyan_builtin_string_length, env, \』内置_字符串长度\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义字符串连接 ^ 』\『, luoyan_function_create（luoyan_builtin_string_concat, env, \』内置_字符串连接\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义整数转字符串 ^ 』\『, luoyan_function_create（luoyan_builtin_int_to_string, env, \』字符串_从_整数\『））;\n』 ^
  『  luoyan_env_bind（env, \』『 ^ 转义字符串转整数 ^ 』\『, luoyan_function_create（luoyan_builtin_string_to_int, env, \』整数_从_字符串\『））;\n』 ^
  『  \n』 ^
  『  // 用户程序\n』 ^
  主代码 ^
  『  \n』 ^
  『  luoyan_env_release（env）;\n』 ^
  『  luoyan_runtime_cleanup（）;\n』 ^
  『  return 0;\n』 ^
  『}\n』

「：主要编译函数：」
夫「编译到C」者受 配置 程序 焉算法乃
  设「C代码」为生成C代码 配置 程序 在

  「：写入C文件：」
  设「输出通道」为打开_输出文件 配置.输出文件 在
  输出_字符串 输出通道 C代码;
  关闭_输出通道 输出通道;

  『C代码已生成到: 』 ^ 配置.输出文件 是谓
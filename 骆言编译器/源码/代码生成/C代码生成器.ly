（*
 * C代码生成器
 * 将骆言抽象语法树转换为C代码
 *）

「：引入依赖模块：」
使用 抽象语法树
使用 工具库
使用 错误处理

「：代码生成配置：」
类型 代码生成配置={
  输出文件: 字符串;
  包含调试信息: 布尔值;
  优化级别: 整数;
  运行时路径: 字符串;
}

「：代码生成上下文：」
类型 代码生成上下文={
  配置: 代码生成配置;
  可变 下一个变量ID: 整数;
  可变 下一个标签ID: 整数;
  可变 包含文件: 字符串 列表;
  可变 全局变量: 字符串 列表;
  可变 函数定义: 字符串 列表;
}

「：创建代码生成上下文：」
夫「创建上下文」者受 配置 焉算法乃 {
  配置=配置;
  下一个变量ID=0;
  下一个标签ID=0;
  包含文件=(列开始 『luoyanruntime.子』 其一 列结束);
  全局变量=空空如也;
  函数定义=空空如也;
} 也

「：生成唯一变量名：」
夫「生成变量名」者受 上下文 前缀 焉算法乃
  设「id」为上下文.下一个变量ID 在
  上下文.下一个变量ID :=id 加 1;
  『luoyanvar_』 ^ 前缀 ^ 『_』 ^ （字符串_从整数 id） 也

「：生成唯一标签名：」
夫「生成标签名」者受 上下文 前缀 焉算法乃
  设「id」为上下文.下一个标签ID 在
  上下文.下一个标签ID :=id 加 1;
  『luoyanlabel_』 ^ 前缀 ^ 『_』 ^ （字符串_从整数 id） 也

「：转义标识符名称：」
夫「转义标识符」者受 名称 焉算法乃
  设 递归 转义字符为函数 字符列表 结果 ->
    观「字符列表」之性
    | 空空如也 -> 反向 结果
    | 字符 :: 剩余 ->
      若 （字符 >='0' && 字符 <='9'） ||
         （字符 >='甲' && 字符 <='终'） ||
         （字符 >='A' && 字符 <='Z'） ||
         字符='_'
      则 答 转义字符 剩余 （字符 :: 结果）
      余者答
        设「代码」为字符_到整数 字符 在
        设「转义字符串」为『_』 ^ （十六进制_从整数 代码） ^ 『_』 在
        转义字符 剩余 （（字符串_到字符列表 转义字符串） @ 结果） 观毕
  在
  字符串_从字符列表 （转义字符 （字符串_到字符列表 名称） 空空如也） 也

「：生成C类型名：」
夫「骆言类型_到C类型」者受 类型 焉算法乃
  观「类型」之性
  | 『整数』 -> 『luoyan_整数t』
  | 『浮点数』 -> 『luoyanfloatt』
  | 『字符串』 -> 『luoyan_字符串t*』
  | 『布尔值』 -> 『luoyan_布尔t』
  | 『单元』 -> 『void』
  | 『列表』 -> 『luoyanlistt*』
  | 『函数』 -> 『luoyanfunctiont*』
  | 『记录』 -> 『luoyanrecordt*』
  | 『数组』 -> 『luoyanarrayt*』
  | 『引用』 -> 『luoyanreft*』
  | _ -> 『luoyanvaluet*』 观毕也

「：生成表达式代码：」
设 递归 生成表达式为函数 上下文 表达式 ->
  观「表达式」之性
  | 字面量表达式 （字面量, _） -> 生成字面量 字面量
  | 变量表达式 （名称, _） ->
    设「转义名称」为转义标识符 名称 在
    『luoyanenvlookup（env, \』『 ^ 转义名称 ^ 』\『）』
  | 二元运算表达式 （左表达式, 运算符, 右表达式, _） ->
    生成二元运算 上下文 运算符 左表达式 右表达式
  | 一元运算表达式 （运算符, 表达式, _） ->
    生成一元运算 上下文 运算符 表达式
  | 条件表达式 （条件, 那么分支, 否则分支, _） ->
    生成条件表达式 上下文 条件 那么分支 否则分支
  | 让绑定表达式 （变量, 值表达式, 主体表达式, _） ->
    生成让绑定表达式 上下文 变量 值表达式 主体表达式
  | 函数表达式 （参数列表, 主体, _） ->
    生成函数表达式 上下文 参数列表 主体
  | 函数调用表达式 （函数表达式, 参数表达式列表, _） ->
    生成调用表达式 上下文 函数表达式 参数表达式列表
  | 模式匹配表达式 （表达式, 模式列表, _） ->
    生成匹配表达式 上下文 表达式 模式列表
  | 列表表达式 （表达式列表, _） ->
    生成列表表达式 上下文 表达式列表
  | 元组表达式 （表达式列表, _） ->
    生成元组表达式 上下文 表达式列表
  | 记录表达式 （字段列表, _） ->
    生成记录表达式 上下文 字段列表
  | 字段访问表达式 （记录表达式, 字段名, _） ->
    生成字段访问表达式 上下文 记录表达式 字段名
  | 记录更新表达式 （记录表达式, 更新列表, _） ->
    生成记录更新表达式 上下文 记录表达式 更新列表
  | 数组表达式 （表达式列表, _） ->
    生成数组表达式 上下文 表达式列表
  | 数组访问表达式 （数组表达式, 索引表达式, _） ->
    生成数组访问表达式 上下文 数组表达式 索引表达式
  | 数组更新表达式 （数组表达式, 索引表达式, 值表达式, _） ->
    生成数组更新表达式 上下文 数组表达式 索引表达式 值表达式
  | 引用表达式 （表达式, _） ->
    生成引用表达式 上下文 表达式
  | 解引用表达式 （表达式, _） ->
    生成解引用表达式 上下文 表达式
  | 赋值表达式 （引用表达式, 值表达式, _） ->
    生成赋值表达式 上下文 引用表达式 值表达式
  | 构造器表达式 （构造器名, 参数列表, _） ->
    生成构造器表达式 上下文 构造器名 参数列表
  | 序列表达式 （表达式列表, _） ->
    生成序列表达式 上下文 表达式列表
  | _ -> 错误 『不支持的表达式类型』 观毕

「：生成字面量代码：」
夫「生成字面量」者受 字面量 焉算法乃
  观「字面量」之性
  | 整数字面量 索引 -> 『luoyan整数（』 ^ （字符串_从整数 索引） ^ 『L）』
  | 浮点字面量 函 -> 『luoyanfloat（』 ^ （字符串_从浮点数 函） ^ 『）』
  | 字符串字面量 串 ->
    设「转义字符串」为为C转义字符串 串 在
    『luoyan字符串（\』『 ^ 转义字符串 ^ 』\『）』
  | 布尔字面量 乙 ->
    『luoyan布尔（』 ^ （若 乙 则 答 『真』 余者答 『假』） ^ 『）』
  | 单元字面量 -> 『luoyanunit（）』 观毕也

「：为C转义字符串：」
夫「为C转义字符串」者受 字符串 焉算法乃
  设 递归 转义字符为函数 字符列表 结果 ->
    观「字符列表」之性
    | 空空如也 -> 反向 结果
    | '『' :: 剩余 -> 转义字符 剩余 （'』' :: '\\' :: 结果）
    | '\\' :: 剩余 -> 转义字符 剩余 （'\\' :: '\\' :: 结果）
    | '\数' :: 剩余 -> 转义字符 剩余 （'数' :: '\\' :: 结果）
    | '\项' :: 剩余 -> 转义字符 剩余 （'项' :: '\\' :: 结果）
    | '\行' :: 剩余 -> 转义字符 剩余 （'行' :: '\\' :: 结果）
    | 字符 :: 剩余 -> 转义字符 剩余 （字符 :: 结果） 观毕
  在
  字符串_从字符列表 （转义字符 （字符串_到字符列表 字符串） 空空如也） 也

「：生成二元运算代码：」
夫「生成二元运算」者受 上下文 运算符 左表达式 右表达式 焉算法乃
  设「左代码」为生成表达式 上下文 左表达式 在
  设「右代码」为生成表达式 上下文 右表达式 在
  观「运算符」之性
  | 加法 -> 『luoyanadd（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 减法 -> 『luoyansubtract（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 乘法 -> 『luoyanmultiply（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 除法 -> 『luoyandivide（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 模运算 -> 『luoyanmodulo（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 等于 -> 『luoyanequal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 不等于 -> 『luoyannotequal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 小于 -> 『luoyanlessthan（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 小于等于 -> 『luoyanlessequal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 大于 -> 『luoyangreaterthan（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 大于等于 -> 『luoyangreaterequal（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 逻辑与 -> 『luoyanlogicaland（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 逻辑或 -> 『luoyanlogicalor（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』
  | 字符串连接 -> 『luoyan_字符串concat（』 ^ 左代码 ^ 『, 』 ^ 右代码 ^ 『）』 观毕也

「：生成一元运算代码：」
夫「生成一元运算」者受 上下文 运算符 表达式 焉算法乃
  设「操作数代码」为生成表达式 上下文 表达式 在
  观「运算符」之性
  | 逻辑非 -> 『luoyanlogicalnot（』 ^ 操作数代码 ^ 『）』
  | 数值取反 -> 『luoyansubtract（luoyan整数（0）, 』 ^ 操作数代码 ^ 『）』 观毕也

「：生成条件表达式代码：」
夫「生成条件表达式」者受 上下文 条件 那么分支 否则分支 焉算法乃
  设「条件变量」为生成变量名 上下文 『cond』 在
  设「条件代码」为生成表达式 上下文 条件 在
  设「那么代码」为生成表达式 上下文 那么分支 在
  设「否则代码」为生成表达式 上下文 否则分支 在
  『（{ luoyanvaluet* 』 ^ 条件变量 ^ 『=』 ^ 条件代码 ^ 『; 』 ^
  『（（』 ^ 条件变量 ^ 『->type==LUOYANBOOL && 』 ^ 条件变量 ^ 『->data.布尔val）） ? （』 ^
  那么代码 ^ 『） : （』 ^ 否则代码 ^ 『）; }）』 也

「：生成让绑定表达式代码：」
夫「生成让绑定表达式」者受 上下文 变量 值表达式 主体表达式 焉算法乃
  设「值代码」为生成表达式 上下文 值表达式 在
  设「转义变量」为转义标识符 变量 在
  设「主体代码」为生成表达式 上下文 主体表达式 在
  『（{ luoyanenvbind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 值代码 ^ 『）; 』 ^ 主体代码 ^ 『; }）』 也

「：生成函数表达式代码：」
夫「生成函数表达式」者受 上下文 参数列表 主体 焉算法乃
  设「函数名」为生成变量名 上下文 『func』 在
  设「主体代码」为生成表达式 上下文 主体 在

  「：为多参数函数创建curry化的函数：」
  设 递归 创建curry化函数为（函数 剩余参数 主体代码 ->
    匹配 剩余参数 与
    | 空空如也 -> 主体代码
    | 参数 :: 其他参数 ->
      设「转义参数」为转义标识符 参数 在
      设「内部主体」为创建curry化函数 其他参数 主体代码 在
      如果 其他参数=空空如也
      那么
        「：最后一个参数，直接返回主体：」
        设「函数实现」为          『luoyanvaluet* 』 ^ 函数名 ^ 『_impl_』 ^ 参数 ^ 『（luoyanenvt* env, luoyanvaluet* arg） {\数』 ^
          『  luoyanenvbind（env, \』『 ^ 转义参数 ^ 』\『, arg）;\数』 ^
          『  return 』 ^ 内部主体 ^ 『;\数』 ^
          『}』 在
        上下文.函数定义 :=函数实现 :: 上下文.函数定义;
        函数实现
      否则
        「：还有更多参数，返回另一个函数：」
        设「下一个函数名」为生成变量名 上下文 『func』 在
        设「函数实现」为          『luoyanvaluet* 』 ^ 函数名 ^ 『_impl_』 ^ 参数 ^ 『（luoyanenvt* env, luoyanvaluet* arg） {\数』 ^
          『  luoyanenvbind（env, \』『 ^ 转义参数 ^ 』\『, arg）;\数』 ^
          『  return luoyanfunctioncreate（』 ^ 下一个函数名 ^ 『_impl_』 ^ （列表头部 其他参数） ^ 『, env, \』『 ^ 下一个函数名 ^ 』\『）;\数』 ^
          『}』 在
        上下文.函数定义 :=函数实现 :: 上下文.函数定义;
        函数实现） 在

  设「_」为创建curry化函数 参数列表 主体代码 在

  匹配 参数列表 与
  | 空空如也 -> 『luoyanunit（）』
  | 第一个参数 :: _ ->
    『luoyanfunctioncreate（』 ^ 函数名 ^ 『_impl_』 ^ 第一个参数 ^ 『, env, \』『 ^ 函数名 ^ 』\『）』 观毕也

「：生成函数调用代码：」
夫「生成调用表达式」者受 上下文 函数表达式 参数表达式列表 焉算法乃
  设「函数代码」为生成表达式 上下文 函数表达式 在
  匹配 参数表达式列表 与
  | 空空如也 -> 函数代码  「：无参数调用：」
  | (列开始 参数表达式 其一 列结束) ->
    设「参数代码」为生成表达式 上下文 参数表达式 在
    『luoyanfunctioncall（』 ^ 函数代码 ^ 『, 』 ^ 参数代码 ^ 『）』
  | _ ->
    「：多参数调用：连续调用curry化的函数：」
    列表_折叠左 （函数 累积函数 参数表达式 ->
      设「参数代码」为生成表达式 上下文 参数表达式 在
      『luoyanfunctioncall（』 ^ 累积函数 ^ 『, 』 ^ 参数代码 ^ 『）』
    ） 函数代码 参数表达式列表 观毕也

「：生成模式匹配表达式代码：」
夫「生成匹配表达式」者受 上下文 表达式 模式列表 焉算法乃
  设「表达式变量」为生成变量名 上下文 『matchexpr』 在
  设「表达式代码」为生成表达式 上下文 表达式 在

  设 递归 生成模式列表为（函数 模式列表 ->
    匹配 模式列表 与
    | 空空如也 -> 『luoyanunit（）』 「：应该不会到达这里：」
    | （模式, 表达式） :: 剩余 ->
      设「模式检查」为生成模式检查 上下文 表达式变量 模式 在
      设「表达式代码」为生成表达式 上下文 表达式 在
      如果 剩余=空空如也
      那么 『（』 ^ 模式检查 ^ 『） ? （』 ^ 表达式代码 ^ 『） : （luoyanunit（））』
      否则 『（』 ^ 模式检查 ^ 『） ? （』 ^ 表达式代码 ^ 『） : （』 ^ （生成模式列表 剩余） ^ 『）』） 在

  『（{ luoyanvaluet* 』 ^ 表达式变量 ^ 『=』 ^ 表达式代码 ^ 『; 』 ^ （生成模式列表 模式列表） ^ 『; }）』 也

「：生成模式检查代码：」
夫「生成模式检查」者受 上下文 表达式变量 模式 焉算法乃
  匹配 模式 与
  | 字面量模式 （整数字面量 索引, _） ->
    『luoyanequals（』 ^ 表达式变量 ^ 『, luoyan整数（』 ^ （字符串_从整数 索引） ^ 『））』
  | 字面量模式 （字符串字面量 串, _） ->
    『luoyanequals（』 ^ 表达式变量 ^ 『, luoyan字符串（\』『 ^ （为C转义字符串 串） ^ 』\『））』
  | 字面量模式 （布尔字面量 乙, _） ->
    『luoyanequals（』 ^ 表达式变量 ^ 『, luoyan布尔（』 ^ （如果 乙 那么 『真』 否则 『假』） ^ 『））』
  | 字面量模式 （单元字面量, _） ->
    『luoyanequals（』 ^ 表达式变量 ^ 『, luoyanunit（））』
  | 字面量模式 （浮点字面量 函, _） ->
    『luoyanequals（』 ^ 表达式变量 ^ 『, luoyanfloat（』 ^ （字符串_从浮点数 函） ^ 『））』
  | 变量模式 （变量, _） ->
    设「转义变量」为转义标识符 变量 在
    『（luoyanenvbind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式变量 ^ 『）, 真）』
  | 空列表模式 _ ->
    『luoyan_list_isempty（』 ^ 表达式变量 ^ 『）->data.布尔val』
  | 列表头尾模式 （头模式, 尾模式, _） ->
    设「头检查」为生成模式检查 上下文 （『luoyanlisthead（』 ^ 表达式变量 ^ 『）』） 头模式 在
    设「尾检查」为生成模式检查 上下文 （『luoyanlisttail（』 ^ 表达式变量 ^ 『）』） 尾模式 在
    『（!luoyan_list_isempty（』 ^ 表达式变量 ^ 『）->data.布尔val && 』 ^ 头检查 ^ 『 && 』 ^ 尾检查 ^ 『）』
  | 通配符模式 _ -> 『真』
  | _ -> 错误 『不支持的模式类型』 观毕也

「：生成列表表达式代码：」
夫「生成列表表达式」者受 上下文 表达式列表 焉算法乃
  设 递归 构建列表为（函数 表达式列表 ->
    观「表达式列表」之性
    | 空空如也 -> 『luoyanlistempty（）』
    | 表达式 :: 剩余 ->
      设「元素代码」为生成表达式 上下文 表达式 在
      设「剩余代码」为构建列表 剩余 在
      『luoyanlistcons（』 ^ 元素代码 ^ 『, 』 ^ 剩余代码 ^ 『）』 观毕） 在
  构建列表 表达式列表 也

「：生成元组表达式代码：」
夫「生成元组表达式」者受 上下文 表达式列表 焉算法乃
  观「表达式列表」之性
  | 空空如也 -> 『luoyanunit（）』
  | (列开始 单个 其一 列结束) -> 生成表达式 上下文 单个
  | _ ->
    「：元组存储为记录，字段名为0, _1, _2等：」
    设「元组变量」为生成变量名 上下文 『tuple』 在
    设「初始化代码」为『luoyanrecordcreate（）』 在
    设「字段赋值」为列表_映射索引 （函数 索引 表达式 ->
      设「字段名」为『_』 ^ （字符串_从整数 索引） 在
      设「字段代码」为生成表达式 上下文 表达式 在
      『luoyan_record_setfield（』 ^ 元组变量 ^ 『, \』『 ^ 字段名 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 表达式列表 在
    设「赋值代码」为字符串连接 『; 』 字段赋值 在
    『（{ luoyanvaluet* 』 ^ 元组变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 元组变量 ^ 『; }）』 观毕也

「：生成记录表达式代码：」
夫「生成记录表达式」者受 上下文 字段列表 焉算法乃
  设「记录变量」为生成变量名 上下文 『record』 在
  设「初始化代码」为『luoyanrecordcreate（）』 在
  匹配 字段列表 与
  | 空空如也 -> 初始化代码
  | _ ->
    设「字段赋值」为列表映射 （函数 （字段名, 字段表达式） ->
      设「字段代码」为生成表达式 上下文 字段表达式 在
      设「转义字段」为转义标识符 字段名 在
      『luoyan_record_setfield（』 ^ 记录变量 ^ 『, \』『 ^ 转义字段 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 字段列表 在
    设「赋值代码」为字符串连接 『; 』 字段赋值 在
    『（{ luoyanvaluet* 』 ^ 记录变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 记录变量 ^ 『; }）』 观毕也

「：生成字段访问表达式代码：」
夫「生成字段访问表达式」者受 上下文 记录表达式 字段名 焉算法乃
  设「记录代码」为生成表达式 上下文 记录表达式 在
  设「转义字段」为转义标识符 字段名 在
  『luoyan_record_getfield（』 ^ 记录代码 ^ 『, \』『 ^ 转义字段 ^ 』\『）』 也

「：生成记录更新表达式代码：」
夫「生成记录更新表达式」者受 上下文 记录表达式 更新列表 焉算法乃
  设「记录代码」为生成表达式 上下文 记录表达式 在
  匹配 更新列表 与
  | 空空如也 -> 记录代码
  | （字段名, 字段表达式） :: 剩余 ->
    设「字段代码」为生成表达式 上下文 字段表达式 在
    设「转义字段」为转义标识符 字段名 在
    设「第一次更新」为『luoyanrecordupdate（』 ^ 记录代码 ^ 『, \』『 ^ 转义字段 ^ 』\『, 』 ^ 字段代码 ^ 『）』 在
    列表_折叠左 （函数 累积代码 （字段名, 字段表达式） ->
      设「字段代码」为生成表达式 上下文 字段表达式 在
      设「转义字段名」为转义标识符 字段名 在
      『luoyanrecordupdate（』 ^ 累积代码 ^ 『, \』『 ^ 转义字段名 ^ 』\『, 』 ^ 字段代码 ^ 『）』
    ） 第一次更新 剩余 观毕也

「：生成数组表达式代码：」
夫「生成数组表达式」者受 上下文 表达式列表 焉算法乃
  匹配 表达式列表 与
  | 空空如也 -> 『luoyanarrayempty（）』
  | _ ->
    设「数组变量」为生成变量名 上下文 『array』 在
    设「初始化代码」为『luoyanarraycreate（』 ^ （字符串_从整数 （列表长度 表达式列表）） ^ 『）』 在
    设「元素赋值」为列表_映射索引 （函数 索引 表达式 ->
      设「元素代码」为生成表达式 上下文 表达式 在
      『luoyanarrayset（』 ^ 数组变量 ^ 『, 』 ^ （字符串_从整数 索引） ^ 『, 』 ^ 元素代码 ^ 『）』
    ） 表达式列表 在
    设「赋值代码」为字符串连接 『; 』 元素赋值 在
    『（{ luoyanvaluet* 』 ^ 数组变量 ^ 『=』 ^ 初始化代码 ^ 『; 』 ^ 赋值代码 ^ 『; 』 ^ 数组变量 ^ 『; }）』 观毕也

「：生成数组访问表达式代码：」
夫「生成数组访问表达式」者受 上下文 数组表达式 索引表达式 焉算法乃
  设「数组代码」为生成表达式 上下文 数组表达式 在
  设「索引代码」为生成表达式 上下文 索引表达式 在
  『luoyanarrayget（』 ^ 数组代码 ^ 『, 』 ^ 索引代码 ^ 『）』 也

「：生成数组更新表达式代码：」
夫「生成数组更新表达式」者受 上下文 数组表达式 索引表达式 值表达式 焉算法乃
  设「数组代码」为生成表达式 上下文 数组表达式 在
  设「索引代码」为生成表达式 上下文 索引表达式 在
  设「值代码」为生成表达式 上下文 值表达式 在
  『luoyanarrayupdate（』 ^ 数组代码 ^ 『, 』 ^ 索引代码 ^ 『, 』 ^ 值代码 ^ 『）』 也

「：生成引用表达式代码：」
夫「生成引用表达式」者受 上下文 表达式 焉算法乃
  设「值代码」为生成表达式 上下文 表达式 在
  『luoyanrefcreate（』 ^ 值代码 ^ 『）』 也

「：生成解引用表达式代码：」
夫「生成解引用表达式」者受 上下文 表达式 焉算法乃
  设「引用代码」为生成表达式 上下文 表达式 在
  『luoyanrefget（』 ^ 引用代码 ^ 『）』 也

「：生成赋值表达式代码：」
夫「生成赋值表达式」者受 上下文 引用表达式 值表达式 焉算法乃
  设「引用代码」为生成表达式 上下文 引用表达式 在
  设「值代码」为生成表达式 上下文 值表达式 在
  『luoyanrefset（』 ^ 引用代码 ^ 『, 』 ^ 值代码 ^ 『）』 也

「：生成构造器表达式代码：」
夫「生成构造器表达式」者受 上下文 构造器名 参数列表 焉算法乃
  设「构造器名称」为转义标识符 构造器名 在
  匹配 参数列表 与
  | 空空如也 ->
    「：无参数构造器，创建一个带有构造器名的记录：」
    『luoyanconstructorcreate（\』『 ^ 构造器名称 ^ 』\『, NULL）』
  | _ ->
    设「参数代码」为列表映射 （生成表达式 上下文） 参数列表 在
    设「参数数组」为字符串连接 『, 』 参数代码 在
    『luoyanconstructorcreate（\』『 ^ 构造器名称 ^ 』\『, luoyan_array_fromvalues（』 ^ 参数数组 ^ 『））』 观毕也

「：生成序列表达式代码：」
夫「生成序列表达式」者受 上下文 表达式列表 焉算法乃
  匹配 表达式列表 与
  | 空空如也 -> 『luoyanunit（）』
  | (列开始 表达式 其一 列结束) -> 生成表达式 上下文 表达式
  | _ ->
    设「表达式代码列表」为列表映射 （生成表达式 上下文） 表达式列表 在
    设「最后一个」为列表最后一个 表达式代码列表 在
    设「前面的」为列表去掉最后一个 表达式代码列表 在
    『（{ 』 ^ （字符串连接 『; 』 前面的） ^ 『; 』 ^ 最后一个 ^ 『; }）』 观毕也

「：生成语句代码：」
夫「生成语句」者受 上下文 语句 焉算法乃
  观「语句」之性
  | 表达式语句 表达式 ->
    设「表达式代码」为生成表达式 上下文 表达式 在
    表达式代码 ^ 『;』
  | 设绑定语句 （变量, 表达式, _） ->
    设「表达式代码」为生成表达式 上下文 表达式 在
    设「转义变量」为转义标识符 变量 在
    『luoyanenvbind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式代码 ^ 『）;』
  | 递归设绑定语句 （变量, 表达式, _） ->
    「：递归函数需要特殊处理：」
    设「转义变量」为转义标识符 变量 在
    设「表达式代码」为生成表达式 上下文 表达式 在
    『luoyanenvbind（env, \』『 ^ 转义变量 ^ 』\『, luoyanunit（））; 』 ^
    『luoyanenvbind（env, \』『 ^ 转义变量 ^ 』\『, 』 ^ 表达式代码 ^ 『）;』
  | 类型定义语句 _ -> 『/* 类型定义在C生成中被忽略 */』
  | 异常定义语句 （_, _, _） -> 『/* 异常定义在C生成中被忽略 */』 观毕也

「：生成程序代码：」
夫「生成程序」者受 上下文 程序 焉算法乃
  设 递归 生成语句列表为（函数 语句列表 ->
    观「语句列表」之性
    | 空空如也 -> 『』
    | 语句 :: 剩余 ->
      设「语句代码」为生成语句 上下文 语句 在
      语句代码 ^ 『\数』 ^ （生成语句列表 剩余） 观毕） 在
  生成语句列表 程序 也

「：生成完整的C代码：」
夫「生成C代码」者受 配置 程序 焉算法乃
  设「上下文」为创建上下文 配置 在

  「：生成主要代码：」
  设「主代码」为生成程序 上下文 程序 在

  「：生成完整的C文件：」
  设「包含文件」为字符串连接 『\数』 （列表映射 （函数 文件 -> 『#include \』『 ^ 文件 ^ 』\『』） 上下文.包含文件） 在
  设「函数定义」为字符串连接 『\数\数』 （反向 上下文.函数定义） 在

  设「转义打印」为转义标识符 『打印』 在
  设「转义读取」为转义标识符 『读取』 在
  设「转义读取文件」为转义标识符 『内置读取文件』 在
  设「转义写入文件」为转义标识符 『内置写入文件』 在
  设「转义文件存在」为转义标识符 『内置文件存在』 在
  设「转义系统参数」为转义标识符 『系统参数列表』 在
  设「转义系统退出」为转义标识符 『系统退出』 在
  设「转义字符串长度」为转义标识符 『内置字符串长度』 在
  设「转义字符串连接」为转义标识符 『内置字符串连接』 在
  设「转义整数转字符串」为转义标识符 『字符串_从整数』 在
  设「转义字符串转整数」为转义标识符 『整数_从字符串』 在
  包含文件 ^ 『\数\数』 ^
  函数定义 ^ 『\数\数』 ^
  『整数 main（整数 argc, char** argv） {\数』 ^
  『  luoyanruntimeinit（）;\数』 ^
  『  luoyan_set_systemargs（argc, argv）;\数』 ^
  『  luoyanenvt* env=luoyanenvcreate（NULL）;\数』 ^
  『  \数』 ^
  『  // 添加内置函数\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义打印 ^ 』\『, luoyanfunctioncreate（luoyan_builtinpr整数, env, \』打印\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义读取 ^ 』\『, luoyanfunctioncreate（luoyanbuiltinread, env, \』读取\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义读取文件 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_readfile, env, \』内置读取文件\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义写入文件 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_writefile, env, \』内置写入文件\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义文件存在 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_fileexists, env, \』内置文件存在\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义系统参数 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_systemargs, env, \』系统参数列表\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义系统退出 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_systemexit, env, \』系统退出\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义字符串长度 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_字符串length, env, \』内置字符串长度\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义字符串连接 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_字符串concat, env, \』内置字符串连接\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义整数转字符串 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_整数_to字符串, env, \』字符串_从整数\『））;\数』 ^
  『  luoyanenvbind（env, \』『 ^ 转义字符串转整数 ^ 』\『, luoyanfunctioncreate（luoyan_builtin_字符串_to整数, env, \』整数_从字符串\『））;\数』 ^
  『  \数』 ^
  『  // 用户程序\数』 ^
  主代码 ^
  『  \数』 ^
  『  luoyanenvrelease（env）;\数』 ^
  『  luoyanruntimecleanup（）;\数』 ^
  『  return 0;\数』 ^
  『}\数』

「：主要编译函数：」
夫「编译到C」者受 配置 程序 焉算法乃
  设「C代码」为生成C代码 配置 程序 在

  「：写入C文件：」
  设「输出通道」为打开输出文件 配置.输出文件 在
  输出字符串 输出通道 C代码;
  关闭输出通道 输出通道;

  『C代码已生成到: 』 ^ 配置.输出文件 也
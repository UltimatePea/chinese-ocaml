(*
 * 类型系统 - 类型检查和类型推导
 * 实现骆言语言的类型检查系统
 *)

(* 引入基础模块 *)
使用 基础工具.工具库
使用 基础工具.位置信息
使用 基础工具.错误处理
使用 基础工具.抽象语法树

(* 类型变量计数器 *)
让 mutable 类型变量计数器 = 0

(* 重置类型变量计数器 *)
让 重置类型变量计数器 = 函数 () ->
  类型变量计数器 := 0

(* 生成新的类型变量 *)
让 生成类型变量 = 函数 () ->
  类型变量计数器 := 类型变量计数器 + 1;
  "t" ^ (字符串化整数 类型变量计数器)

(* 内部类型表示 *)
类型 内部类型 =
  | 基础类型 的 字符串
  | 类型变量 的 字符串
  | 函数类型 的 内部类型 * 内部类型
  | 元组类型 的 内部类型 列表
  | 列表类型 的 内部类型
  | 记录类型 的 (字符串 * 内部类型) 列表
  | 变体类型 的 字符串 * 内部类型 列表
  | 引用类型 的 内部类型
  | 数组类型 的 内部类型

(* 类型约束 *)
类型 类型约束 = 内部类型 * 内部类型

(* 类型环境 *)
类型 类型环境 = {
  变量类型: (字符串, 内部类型) 字典;
  类型定义: (字符串, 内部类型) 字典;
  类型约束: 类型约束 列表 参考;
}

(* 创建类型环境 *)
让 创建类型环境 = 函数 () ->
  {
    变量类型 = 创建字典 ();
    类型定义 = 创建字典 ();
    类型约束 = 参考 [];
  }

(* 复制类型环境 *)
让 复制类型环境 = 函数 环境 ->
  {
    变量类型 = 复制字典 环境.变量类型;
    类型定义 = 复制字典 环境.类型定义;
    类型约束 = 参考 !(环境.类型约束);
  }

(* 在类型环境中绑定变量类型 *)
让 绑定变量类型 = 函数 环境 变量名 类型 ->
  字典添加 环境.变量类型 变量名 类型

(* 在类型环境中查找变量类型 *)
让 查找变量类型 = 函数 环境 变量名 ->
  if 字典包含键 环境.变量类型 变量名 then
    有 (字典获取 环境.变量类型 变量名)
  else
    无

(* 添加类型约束 *)
让 添加类型约束 = 函数 环境 类型1 类型2 ->
  环境.类型约束 := (类型1, 类型2) :: !(环境.类型约束)

(* 类型相等检查 *)
让 递归 类型相等 = 函数 类型1 类型2 ->
  匹配 (类型1, 类型2) 的
  | (基础类型 名称1, 基础类型 名称2) -> 名称1 = 名称2
  | (类型变量 变量1, 类型变量 变量2) -> 变量1 = 变量2
  | (函数类型 (参数1, 返回1), 函数类型 (参数2, 返回2)) ->
      类型相等 参数1 参数2 && 类型相等 返回1 返回2
  | (元组类型 类型列表1, 元组类型 类型列表2) ->
      List.length 类型列表1 = List.length 类型列表2 &&
      List.for_all2 类型相等 类型列表1 类型列表2
  | (列表类型 元素类型1, 列表类型 元素类型2) ->
      类型相等 元素类型1 元素类型2
  | (引用类型 内容类型1, 引用类型 内容类型2) ->
      类型相等 内容类型1 内容类型2
  | (数组类型 元素类型1, 数组类型 元素类型2) ->
      类型相等 元素类型1 元素类型2
  | _ -> false

(* 类型统一算法 *)
让 递归 统一类型 = 函数 环境 类型1 类型2 ->
  if 类型相等 类型1 类型2 then
    成功 ()
  else
    匹配 (类型1, 类型2) 的
    | (类型变量 变量, 类型) | (类型, 类型变量 变量) ->
        if 类型包含变量 类型 变量 then
          错误 ("循环类型约束: " ^ 变量 ^ " 出现在 " ^ (格式化类型 类型))
        else (
          添加类型约束 环境 (类型变量 变量) 类型;
          成功 ()
        )
    | (函数类型 (参数1, 返回1), 函数类型 (参数2, 返回2)) ->
        匹配 统一类型 环境 参数1 参数2 的
        | 错误 信息 -> 错误 信息
        | 成功 () -> 统一类型 环境 返回1 返回2
    | (元组类型 类型列表1, 元组类型 类型列表2) ->
        if List.length 类型列表1 <> List.length 类型列表2 then
          错误 ("元组长度不匹配")
        else
          统一类型列表 环境 类型列表1 类型列表2
    | (列表类型 元素类型1, 列表类型 元素类型2) ->
        统一类型 环境 元素类型1 元素类型2
    | (引用类型 内容类型1, 引用类型 内容类型2) ->
        统一类型 环境 内容类型1 内容类型2
    | (数组类型 元素类型1, 数组类型 元素类型2) ->
        统一类型 环境 元素类型1 元素类型2
    | _ ->
        错误 ("无法统一类型: " ^ (格式化类型 类型1) ^ " 和 " ^ (格式化类型 类型2))

和 统一类型列表 = 函数 环境 类型列表1 类型列表2 ->
  匹配 (类型列表1, 类型列表2) 的
  | ([], []) -> 成功 ()
  | (类型1 :: 其余1, 类型2 :: 其余2) ->
      匹配 统一类型 环境 类型1 类型2 的
      | 错误 信息 -> 错误 信息
      | 成功 () -> 统一类型列表 环境 其余1 其余2
  | _ -> 错误 ("类型列表长度不匹配")

和 类型包含变量 = 函数 类型 变量 ->
  匹配 类型 的
  | 基础类型 _ -> false
  | 类型变量 变量名 -> 变量名 = 变量
  | 函数类型 (参数类型, 返回类型) ->
      类型包含变量 参数类型 变量 || 类型包含变量 返回类型 变量
  | 元组类型 类型列表 ->
      List.exists (函数 类型 -> 类型包含变量 类型 变量) 类型列表
  | 列表类型 元素类型 ->
      类型包含变量 元素类型 变量
  | 记录类型 字段列表 ->
      List.exists (函数 (_, 类型) -> 类型包含变量 类型 变量) 字段列表
  | 变体类型 (_, 参数类型列表) ->
      List.exists (函数 类型 -> 类型包含变量 类型 变量) 参数类型列表
  | 引用类型 内容类型 ->
      类型包含变量 内容类型 变量
  | 数组类型 元素类型 ->
      类型包含变量 元素类型 变量

和 格式化类型 = 函数 类型 ->
  匹配 类型 的
  | 基础类型 名称 -> 名称
  | 类型变量 变量 -> "'" ^ 变量
  | 函数类型 (参数类型, 返回类型) ->
      "(" ^ (格式化类型 参数类型) ^ " -> " ^ (格式化类型 返回类型) ^ ")"
  | 元组类型 类型列表 ->
      "(" ^ (字符串连接 " * " (List.map 格式化类型 类型列表)) ^ ")"
  | 列表类型 元素类型 ->
      (格式化类型 元素类型) ^ " 列表"
  | 记录类型 字段列表 ->
      "{ " ^ (字符串连接 "; " (List.map (函数 (名称, 类型) ->
        名称 ^ ": " ^ (格式化类型 类型)) 字段列表)) ^ " }"
  | 变体类型 (名称, 参数类型列表) ->
      名称 ^ (if 参数类型列表 = [] then "" 
              else " (" ^ (字符串连接 " * " (List.map 格式化类型 参数类型列表)) ^ ")")
  | 引用类型 内容类型 ->
      (格式化类型 内容类型) ^ " 引用"
  | 数组类型 元素类型 ->
      (格式化类型 元素类型) ^ " 数组"

(* 从类型表达式转换为内部类型 *)
让 递归 类型表达式到内部类型 = 函数 环境 类型表达式 ->
  匹配 类型表达式 的
  | 基础类型 (名称, _) -> 基础类型 名称
  | 类型变量 (变量, _) -> 类型变量 变量
  | 函数类型 (参数类型, 返回类型, _) ->
      let 参数 = 类型表达式到内部类型 环境 参数类型 在
      let 返回 = 类型表达式到内部类型 环境 返回类型 在
      函数类型 (参数, 返回)
  | 元组类型 (类型列表, _) ->
      let 内部类型列表 = List.map (类型表达式到内部类型 环境) 类型列表 在
      元组类型 内部类型列表
  | 列表类型 (元素类型, _) ->
      let 元素 = 类型表达式到内部类型 环境 元素类型 在
      列表类型 元素
  | 记录类型 (字段列表, _) ->
      let 内部字段列表 = List.map (函数 (名称, 类型) ->
        (名称, 类型表达式到内部类型 环境 类型)) 字段列表 在
      记录类型 内部字段列表
  | 变体类型 (名称, 参数类型列表, _) ->
      let 内部参数类型列表 = List.map (类型表达式到内部类型 环境) 参数类型列表 在
      变体类型 (名称, 内部参数类型列表)
  | 引用类型 (内容类型, _) ->
      let 内容 = 类型表达式到内部类型 环境 内容类型 在
      引用类型 内容
  | 数组类型 (元素类型, _) ->
      let 元素 = 类型表达式到内部类型 环境 元素类型 在
      数组类型 元素

(* 推导字面量类型 *)
让 推导字面量类型 = 函数 字面量 ->
  匹配 字面量 的
  | 整数字面量 _ -> 基础类型 "整数"
  | 浮点字面量 _ -> 基础类型 "浮点数"
  | 字符串字面量 _ -> 基础类型 "字符串"
  | 布尔字面量 _ -> 基础类型 "布尔值"
  | 单元字面量 -> 基础类型 "单元"

(* 推导二元运算类型 *)
让 推导二元运算类型 = 函数 运算符 左类型 右类型 ->
  匹配 运算符 的
  | 加法 | 减法 | 乘法 | 除法 | 模运算 ->
      if 类型相等 左类型 (基础类型 "整数") && 类型相等 右类型 (基础类型 "整数") then
        成功 (基础类型 "整数")
      else if 类型相等 左类型 (基础类型 "浮点数") && 类型相等 右类型 (基础类型 "浮点数") then
        成功 (基础类型 "浮点数")
      else
        错误 ("算术运算要求数值类型")
  | 等于 | 不等于 ->
      if 类型相等 左类型 右类型 then
        成功 (基础类型 "布尔值")
      else
        错误 ("相等比较要求相同类型")
  | 小于 | 小于等于 | 大于 | 大于等于 ->
      if (类型相等 左类型 (基础类型 "整数") && 类型相等 右类型 (基础类型 "整数")) ||
         (类型相等 左类型 (基础类型 "浮点数") && 类型相等 右类型 (基础类型 "浮点数")) then
        成功 (基础类型 "布尔值")
      else
        错误 ("数值比较要求数值类型")
  | 逻辑与 | 逻辑或 ->
      if 类型相等 左类型 (基础类型 "布尔值") && 类型相等 右类型 (基础类型 "布尔值") then
        成功 (基础类型 "布尔值")
      else
        错误 ("逻辑运算要求布尔类型")
  | 字符串连接 ->
      if 类型相等 左类型 (基础类型 "字符串") && 类型相等 右类型 (基础类型 "字符串") then
        成功 (基础类型 "字符串")
      else
        错误 ("字符串连接要求字符串类型")

(* 推导一元运算类型 *)
让 推导一元运算类型 = 函数 运算符 操作数类型 ->
  匹配 运算符 的
  | 逻辑非 ->
      if 类型相等 操作数类型 (基础类型 "布尔值") then
        成功 (基础类型 "布尔值")
      else
        错误 ("逻辑非运算要求布尔类型")
  | 数值取反 ->
      if 类型相等 操作数类型 (基础类型 "整数") then
        成功 (基础类型 "整数")
      else if 类型相等 操作数类型 (基础类型 "浮点数") then
        成功 (基础类型 "浮点数")
      else
        错误 ("数值取反要求数值类型")

(* 初始化基础类型环境 *)
让 初始化基础类型环境 = 函数 环境 ->
  字典添加 环境.类型定义 "整数" (基础类型 "整数");
  字典添加 环境.类型定义 "浮点数" (基础类型 "浮点数");
  字典添加 环境.类型定义 "字符串" (基础类型 "字符串");
  字典添加 环境.类型定义 "布尔值" (基础类型 "布尔值");
  字典添加 环境.类型定义 "单元" (基础类型 "单元")
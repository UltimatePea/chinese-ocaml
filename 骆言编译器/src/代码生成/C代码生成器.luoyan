(*
 * C代码生成器
 * 将骆言抽象语法树转换为C代码
 *)

(* 引入依赖模块 *)
使用 抽象语法树
使用 工具库
使用 错误处理

(* 代码生成配置 *)
类型 代码生成配置 = {
  输出文件: 字符串;
  包含调试信息: 布尔值;
  优化级别: 整数;
  运行时路径: 字符串;
}

(* 代码生成上下文 *)
类型 代码生成上下文 = {
  配置: 代码生成配置;
  可变 下一个变量ID: 整数;
  可变 下一个标签ID: 整数;
  可变 包含文件: 字符串 列表;
  可变 全局变量: 字符串 列表;
  可变 函数定义: 字符串 列表;
}

(* 创建代码生成上下文 *)
让 创建上下文 = 函数 配置 -> {
  配置 = 配置;
  下一个变量ID = 0;
  下一个标签ID = 0;
  包含文件 = ["luoyan_runtime.h"];
  全局变量 = [];
  函数定义 = [];
}

(* 生成唯一变量名 *)
让 生成变量名 = 函数 上下文 前缀 ->
  让 id = 上下文.下一个变量ID 在
  上下文.下一个变量ID := id + 1;
  "luoyan_var_" ^ 前缀 ^ "_" ^ (字符串_从_整数 id)

(* 生成唯一标签名 *)
让 生成标签名 = 函数 上下文 前缀 ->
  让 id = 上下文.下一个标签ID 在
  上下文.下一个标签ID := id + 1;
  "luoyan_label_" ^ 前缀 ^ "_" ^ (字符串_从_整数 id)

(* 转义标识符名称 *)
让 转义标识符 = 函数 名称 ->
  让 递归 转义字符 = 函数 字符列表 结果 ->
    匹配 字符列表 与
    | [] -> 反向 结果
    | 字符 :: 剩余 ->
      如果 (字符 >= '0' && 字符 <= '9') || 
         (字符 >= 'a' && 字符 <= 'z') || 
         (字符 >= 'A' && 字符 <= 'Z') || 
         字符 = '_'
      那么 转义字符 剩余 (字符 :: 结果)
      否则
        让 代码 = 字符_到_整数 字符 在
        让 转义字符串 = "_" ^ (十六进制_从_整数 代码) ^ "_" 在
        转义字符 剩余 ((字符串_到_字符列表 转义字符串) @ 结果)
  在
  字符串_从_字符列表 (转义字符 (字符串_到_字符列表 名称) [])

(* 生成C类型名 *)
让 骆言类型_到_C类型 = 函数 类型 ->
  匹配 类型 与
  | "整数" -> "luoyan_int_t"
  | "浮点数" -> "luoyan_float_t"
  | "字符串" -> "luoyan_string_t*"
  | "布尔值" -> "luoyan_bool_t"
  | "单元" -> "void"
  | "列表" -> "luoyan_list_t*"
  | "函数" -> "luoyan_function_t*"
  | "记录" -> "luoyan_record_t*"
  | "数组" -> "luoyan_array_t*"
  | "引用" -> "luoyan_ref_t*"
  | _ -> "luoyan_value_t*"

(* 生成表达式代码 *)
让 递归 生成表达式 = 函数 上下文 表达式 ->
  匹配 表达式 与
  | 字面量表达式 (字面量, _) -> 生成字面量 字面量
  | 变量表达式 (名称, _) -> 
    让 转义名称 = 转义标识符 名称 在
    "luoyan_env_lookup(env, \"" ^ 转义名称 ^ "\")"
  | 二元运算表达式 (左表达式, 运算符, 右表达式, _) ->
    生成二元运算 上下文 运算符 左表达式 右表达式
  | 一元运算表达式 (运算符, 表达式, _) ->
    生成一元运算 上下文 运算符 表达式
  | 条件表达式 (条件, 那么分支, 否则分支, _) ->
    生成条件表达式 上下文 条件 那么分支 否则分支
  | 让绑定表达式 (变量, 值表达式, 主体表达式, _) ->
    生成让绑定表达式 上下文 变量 值表达式 主体表达式
  | 函数表达式 (参数列表, 主体, _) ->
    生成函数表达式 上下文 参数列表 主体
  | 函数调用表达式 (函数表达式, 参数表达式列表, _) ->
    生成调用表达式 上下文 函数表达式 参数表达式列表
  | 模式匹配表达式 (表达式, 模式列表, _) ->
    生成匹配表达式 上下文 表达式 模式列表
  | 列表表达式 (表达式列表, _) ->
    生成列表表达式 上下文 表达式列表
  | 元组表达式 (表达式列表, _) ->
    生成元组表达式 上下文 表达式列表
  | 记录表达式 (字段列表, _) ->
    生成记录表达式 上下文 字段列表
  | 字段访问表达式 (记录表达式, 字段名, _) ->
    生成字段访问表达式 上下文 记录表达式 字段名
  | 记录更新表达式 (记录表达式, 更新列表, _) ->
    生成记录更新表达式 上下文 记录表达式 更新列表
  | 数组表达式 (表达式列表, _) ->
    生成数组表达式 上下文 表达式列表
  | 数组访问表达式 (数组表达式, 索引表达式, _) ->
    生成数组访问表达式 上下文 数组表达式 索引表达式
  | 数组更新表达式 (数组表达式, 索引表达式, 值表达式, _) ->
    生成数组更新表达式 上下文 数组表达式 索引表达式 值表达式
  | 引用表达式 (表达式, _) ->
    生成引用表达式 上下文 表达式
  | 解引用表达式 (表达式, _) ->
    生成解引用表达式 上下文 表达式
  | 赋值表达式 (引用表达式, 值表达式, _) ->
    生成赋值表达式 上下文 引用表达式 值表达式
  | 构造器表达式 (构造器名, 参数列表, _) ->
    生成构造器表达式 上下文 构造器名 参数列表
  | 序列表达式 (表达式列表, _) ->
    生成序列表达式 上下文 表达式列表
  | _ -> 错误 "不支持的表达式类型"

(* 生成字面量代码 *)
和 生成字面量 = 函数 字面量 ->
  匹配 字面量 与
  | 整数字面量 i -> "luoyan_int(" ^ (字符串_从_整数 i) ^ "L)"
  | 浮点字面量 f -> "luoyan_float(" ^ (字符串_从_浮点数 f) ^ ")"
  | 字符串字面量 s -> 
    让 转义字符串 = 为C转义字符串 s 在
    "luoyan_string(\"" ^ 转义字符串 ^ "\")"
  | 布尔字面量 b -> 
    "luoyan_bool(" ^ (如果 b 那么 "true" 否则 "false") ^ ")"
  | 单元字面量 -> "luoyan_unit()"

(* 为C转义字符串 *)
和 为C转义字符串 = 函数 字符串 ->
  让 递归 转义字符 = 函数 字符列表 结果 ->
    匹配 字符列表 与
    | [] -> 反向 结果
    | '"' :: 剩余 -> 转义字符 剩余 ('"' :: '\\' :: 结果)
    | '\\' :: 剩余 -> 转义字符 剩余 ('\\' :: '\\' :: 结果)
    | '\n' :: 剩余 -> 转义字符 剩余 ('n' :: '\\' :: 结果)
    | '\t' :: 剩余 -> 转义字符 剩余 ('t' :: '\\' :: 结果)
    | '\r' :: 剩余 -> 转义字符 剩余 ('r' :: '\\' :: 结果)
    | 字符 :: 剩余 -> 转义字符 剩余 (字符 :: 结果)
  在
  字符串_从_字符列表 (转义字符 (字符串_到_字符列表 字符串) [])

(* 生成二元运算代码 *)
和 生成二元运算 = 函数 上下文 运算符 左表达式 右表达式 ->
  让 左代码 = 生成表达式 上下文 左表达式 在
  让 右代码 = 生成表达式 上下文 右表达式 在
  匹配 运算符 与
  | 加法 -> "luoyan_add(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 减法 -> "luoyan_subtract(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 乘法 -> "luoyan_multiply(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 除法 -> "luoyan_divide(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 模运算 -> "luoyan_modulo(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 等于 -> "luoyan_equal(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 不等于 -> "luoyan_not_equal(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 小于 -> "luoyan_less_than(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 小于等于 -> "luoyan_less_equal(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 大于 -> "luoyan_greater_than(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 大于等于 -> "luoyan_greater_equal(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 逻辑与 -> "luoyan_logical_and(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 逻辑或 -> "luoyan_logical_or(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"
  | 字符串连接 -> "luoyan_string_concat(" ^ 左代码 ^ ", " ^ 右代码 ^ ")"

(* 生成一元运算代码 *)
和 生成一元运算 = 函数 上下文 运算符 表达式 ->
  让 操作数代码 = 生成表达式 上下文 表达式 在
  匹配 运算符 与
  | 逻辑非 -> "luoyan_logical_not(" ^ 操作数代码 ^ ")"
  | 数值取反 -> "luoyan_subtract(luoyan_int(0), " ^ 操作数代码 ^ ")"

(* 生成条件表达式代码 *)
和 生成条件表达式 = 函数 上下文 条件 那么分支 否则分支 ->
  让 条件变量 = 生成变量名 上下文 "cond" 在
  让 条件代码 = 生成表达式 上下文 条件 在
  让 那么代码 = 生成表达式 上下文 那么分支 在
  让 否则代码 = 生成表达式 上下文 否则分支 在
  "({ luoyan_value_t* " ^ 条件变量 ^ " = " ^ 条件代码 ^ "; " ^
  "((" ^ 条件变量 ^ "->type == LUOYAN_BOOL && " ^ 条件变量 ^ "->data.bool_val)) ? (" ^ 
  那么代码 ^ ") : (" ^ 否则代码 ^ "); })"

(* 生成让绑定表达式代码 *)
和 生成让绑定表达式 = 函数 上下文 变量 值表达式 主体表达式 ->
  让 值代码 = 生成表达式 上下文 值表达式 在
  让 转义变量 = 转义标识符 变量 在
  让 主体代码 = 生成表达式 上下文 主体表达式 在
  "({ luoyan_env_bind(env, \"" ^ 转义变量 ^ "\", " ^ 值代码 ^ "); " ^ 主体代码 ^ "; })"

(* 生成函数表达式代码 *)
和 生成函数表达式 = 函数 上下文 参数列表 主体 ->
  让 函数名 = 生成变量名 上下文 "func" 在
  让 主体代码 = 生成表达式 上下文 主体 在
  
  (* 为多参数函数创建curry化的函数 *)
  让 递归 创建curry化函数 = 函数 剩余参数 主体代码 ->
    匹配 剩余参数 与
    | [] -> 主体代码
    | 参数 :: 其他参数 ->
      让 转义参数 = 转义标识符 参数 在
      让 内部主体 = 创建curry化函数 其他参数 主体代码 在
      如果 其他参数 = []
      那么
        (* 最后一个参数，直接返回主体 *)
        让 函数实现 = 
          "luoyan_value_t* " ^ 函数名 ^ "_impl_" ^ 参数 ^ "(luoyan_env_t* env, luoyan_value_t* arg) {\n" ^
          "  luoyan_env_bind(env, \"" ^ 转义参数 ^ "\", arg);\n" ^
          "  return " ^ 内部主体 ^ ";\n" ^
          "}" 在
        上下文.函数定义 := 函数实现 :: 上下文.函数定义;
        函数实现
      否则
        (* 还有更多参数，返回另一个函数 *)
        让 下一个函数名 = 生成变量名 上下文 "func" 在
        让 函数实现 = 
          "luoyan_value_t* " ^ 函数名 ^ "_impl_" ^ 参数 ^ "(luoyan_env_t* env, luoyan_value_t* arg) {\n" ^
          "  luoyan_env_bind(env, \"" ^ 转义参数 ^ "\", arg);\n" ^
          "  return luoyan_function_create(" ^ 下一个函数名 ^ "_impl_" ^ (列表_头部 其他参数) ^ ", env, \"" ^ 下一个函数名 ^ "\");\n" ^
          "}" 在
        上下文.函数定义 := 函数实现 :: 上下文.函数定义;
        函数实现
  在
  
  让 _ = 创建curry化函数 参数列表 主体代码 在
  
  匹配 参数列表 与
  | [] -> "luoyan_unit()"
  | 第一个参数 :: _ ->
    "luoyan_function_create(" ^ 函数名 ^ "_impl_" ^ 第一个参数 ^ ", env, \"" ^ 函数名 ^ "\")"

(* 生成函数调用代码 *)
和 生成调用表达式 = 函数 上下文 函数表达式 参数表达式列表 ->
  让 函数代码 = 生成表达式 上下文 函数表达式 在
  匹配 参数表达式列表 与
  | [] -> 函数代码  (* 无参数调用 *)
  | [参数表达式] ->
    让 参数代码 = 生成表达式 上下文 参数表达式 在
    "luoyan_function_call(" ^ 函数代码 ^ ", " ^ 参数代码 ^ ")"
  | _ ->
    (* 多参数调用：连续调用curry化的函数 *)
    列表_折叠_左 (函数 累积函数 参数表达式 ->
      让 参数代码 = 生成表达式 上下文 参数表达式 在
      "luoyan_function_call(" ^ 累积函数 ^ ", " ^ 参数代码 ^ ")"
    ) 函数代码 参数表达式列表

(* 生成模式匹配表达式代码 *)
和 生成匹配表达式 = 函数 上下文 表达式 模式列表 ->
  让 表达式变量 = 生成变量名 上下文 "match_expr" 在
  让 表达式代码 = 生成表达式 上下文 表达式 在
  
  让 递归 生成模式列表 = 函数 模式列表 ->
    匹配 模式列表 与
    | [] -> "luoyan_unit()" (* 应该不会到达这里 *)
    | (模式, 表达式) :: 剩余 ->
      让 模式检查 = 生成模式检查 上下文 表达式变量 模式 在
      让 表达式代码 = 生成表达式 上下文 表达式 在
      如果 剩余 = []
      那么 "(" ^ 模式检查 ^ ") ? (" ^ 表达式代码 ^ ") : (luoyan_unit())"
      否则 "(" ^ 模式检查 ^ ") ? (" ^ 表达式代码 ^ ") : (" ^ (生成模式列表 剩余) ^ ")"
  在
  
  "({ luoyan_value_t* " ^ 表达式变量 ^ " = " ^ 表达式代码 ^ "; " ^ (生成模式列表 模式列表) ^ "; })"

(* 生成模式检查代码 *)
和 生成模式检查 = 函数 上下文 表达式变量 模式 ->
  匹配 模式 与
  | 字面量模式 (整数字面量 i, _) -> 
    "luoyan_equals(" ^ 表达式变量 ^ ", luoyan_int(" ^ (字符串_从_整数 i) ^ "))"
  | 字面量模式 (字符串字面量 s, _) -> 
    "luoyan_equals(" ^ 表达式变量 ^ ", luoyan_string(\"" ^ (为C转义字符串 s) ^ "\"))"
  | 字面量模式 (布尔字面量 b, _) -> 
    "luoyan_equals(" ^ 表达式变量 ^ ", luoyan_bool(" ^ (如果 b 那么 "true" 否则 "false") ^ "))"
  | 字面量模式 (单元字面量, _) -> 
    "luoyan_equals(" ^ 表达式变量 ^ ", luoyan_unit())"
  | 字面量模式 (浮点字面量 f, _) -> 
    "luoyan_equals(" ^ 表达式变量 ^ ", luoyan_float(" ^ (字符串_从_浮点数 f) ^ "))"
  | 变量模式 (变量, _) -> 
    让 转义变量 = 转义标识符 变量 在
    "(luoyan_env_bind(env, \"" ^ 转义变量 ^ "\", " ^ 表达式变量 ^ "), true)"
  | 空列表模式 _ -> 
    "luoyan_list_is_empty(" ^ 表达式变量 ^ ")->data.bool_val"
  | 列表头尾模式 (头模式, 尾模式, _) -> 
    让 头检查 = 生成模式检查 上下文 ("luoyan_list_head(" ^ 表达式变量 ^ ")") 头模式 在
    让 尾检查 = 生成模式检查 上下文 ("luoyan_list_tail(" ^ 表达式变量 ^ ")") 尾模式 在
    "(!luoyan_list_is_empty(" ^ 表达式变量 ^ ")->data.bool_val && " ^ 头检查 ^ " && " ^ 尾检查 ^ ")"
  | 通配符模式 _ -> "true"
  | _ -> 错误 "不支持的模式类型"

(* 生成列表表达式代码 *)
和 生成列表表达式 = 函数 上下文 表达式列表 ->
  让 递归 构建列表 = 函数 表达式列表 ->
    匹配 表达式列表 与
    | [] -> "luoyan_list_empty()"
    | 表达式 :: 剩余 -> 
      让 元素代码 = 生成表达式 上下文 表达式 在
      让 剩余代码 = 构建列表 剩余 在
      "luoyan_list_cons(" ^ 元素代码 ^ ", " ^ 剩余代码 ^ ")"
  在
  构建列表 表达式列表

(* 生成元组表达式代码 *)
和 生成元组表达式 = 函数 上下文 表达式列表 ->
  匹配 表达式列表 与
  | [] -> "luoyan_unit()"
  | [单个] -> 生成表达式 上下文 单个
  | _ ->
    (* 元组存储为记录，字段名为_0, _1, _2等 *)
    让 元组变量 = 生成变量名 上下文 "tuple" 在
    让 初始化代码 = "luoyan_record_create()" 在
    让 字段赋值 = 列表_映射_索引 (函数 i 表达式 ->
      让 字段名 = "_" ^ (字符串_从_整数 i) 在
      让 字段代码 = 生成表达式 上下文 表达式 在
      "luoyan_record_set_field(" ^ 元组变量 ^ ", \"" ^ 字段名 ^ "\", " ^ 字段代码 ^ ")"
    ) 表达式列表 在
    让 赋值代码 = 字符串_连接 "; " 字段赋值 在
    "({ luoyan_value_t* " ^ 元组变量 ^ " = " ^ 初始化代码 ^ "; " ^ 赋值代码 ^ "; " ^ 元组变量 ^ "; })"

(* 生成记录表达式代码 *)
和 生成记录表达式 = 函数 上下文 字段列表 ->
  让 记录变量 = 生成变量名 上下文 "record" 在
  让 初始化代码 = "luoyan_record_create()" 在
  匹配 字段列表 与
  | [] -> 初始化代码
  | _ -> 
    让 字段赋值 = 列表_映射 (函数 (字段名, 字段表达式) ->
      让 字段代码 = 生成表达式 上下文 字段表达式 在
      让 转义字段 = 转义标识符 字段名 在
      "luoyan_record_set_field(" ^ 记录变量 ^ ", \"" ^ 转义字段 ^ "\", " ^ 字段代码 ^ ")"
    ) 字段列表 在
    让 赋值代码 = 字符串_连接 "; " 字段赋值 在
    "({ luoyan_value_t* " ^ 记录变量 ^ " = " ^ 初始化代码 ^ "; " ^ 赋值代码 ^ "; " ^ 记录变量 ^ "; })"

(* 生成字段访问表达式代码 *)
和 生成字段访问表达式 = 函数 上下文 记录表达式 字段名 ->
  让 记录代码 = 生成表达式 上下文 记录表达式 在
  让 转义字段 = 转义标识符 字段名 在
  "luoyan_record_get_field(" ^ 记录代码 ^ ", \"" ^ 转义字段 ^ "\")"

(* 生成记录更新表达式代码 *)
和 生成记录更新表达式 = 函数 上下文 记录表达式 更新列表 ->
  让 记录代码 = 生成表达式 上下文 记录表达式 在
  匹配 更新列表 与
  | [] -> 记录代码
  | (字段名, 字段表达式) :: 剩余 ->
    让 字段代码 = 生成表达式 上下文 字段表达式 在
    让 转义字段 = 转义标识符 字段名 在
    让 第一次更新 = "luoyan_record_update(" ^ 记录代码 ^ ", \"" ^ 转义字段 ^ "\", " ^ 字段代码 ^ ")" 在
    列表_折叠_左 (函数 累积代码 (字段名, 字段表达式) ->
      让 字段代码 = 生成表达式 上下文 字段表达式 在
      让 转义字段名 = 转义标识符 字段名 在
      "luoyan_record_update(" ^ 累积代码 ^ ", \"" ^ 转义字段名 ^ "\", " ^ 字段代码 ^ ")"
    ) 第一次更新 剩余

(* 生成数组表达式代码 *)
和 生成数组表达式 = 函数 上下文 表达式列表 ->
  匹配 表达式列表 与
  | [] -> "luoyan_array_empty()"
  | _ ->
    让 数组变量 = 生成变量名 上下文 "array" 在
    让 初始化代码 = "luoyan_array_create(" ^ (字符串_从_整数 (列表_长度 表达式列表)) ^ ")" 在
    让 元素赋值 = 列表_映射_索引 (函数 i 表达式 ->
      让 元素代码 = 生成表达式 上下文 表达式 在
      "luoyan_array_set(" ^ 数组变量 ^ ", " ^ (字符串_从_整数 i) ^ ", " ^ 元素代码 ^ ")"
    ) 表达式列表 在
    让 赋值代码 = 字符串_连接 "; " 元素赋值 在
    "({ luoyan_value_t* " ^ 数组变量 ^ " = " ^ 初始化代码 ^ "; " ^ 赋值代码 ^ "; " ^ 数组变量 ^ "; })"

(* 生成数组访问表达式代码 *)
和 生成数组访问表达式 = 函数 上下文 数组表达式 索引表达式 ->
  让 数组代码 = 生成表达式 上下文 数组表达式 在
  让 索引代码 = 生成表达式 上下文 索引表达式 在
  "luoyan_array_get(" ^ 数组代码 ^ ", " ^ 索引代码 ^ ")"

(* 生成数组更新表达式代码 *)
和 生成数组更新表达式 = 函数 上下文 数组表达式 索引表达式 值表达式 ->
  让 数组代码 = 生成表达式 上下文 数组表达式 在
  让 索引代码 = 生成表达式 上下文 索引表达式 在
  让 值代码 = 生成表达式 上下文 值表达式 在
  "luoyan_array_update(" ^ 数组代码 ^ ", " ^ 索引代码 ^ ", " ^ 值代码 ^ ")"

(* 生成引用表达式代码 *)
和 生成引用表达式 = 函数 上下文 表达式 ->
  让 值代码 = 生成表达式 上下文 表达式 在
  "luoyan_ref_create(" ^ 值代码 ^ ")"

(* 生成解引用表达式代码 *)
和 生成解引用表达式 = 函数 上下文 表达式 ->
  让 引用代码 = 生成表达式 上下文 表达式 在
  "luoyan_ref_get(" ^ 引用代码 ^ ")"

(* 生成赋值表达式代码 *)
和 生成赋值表达式 = 函数 上下文 引用表达式 值表达式 ->
  让 引用代码 = 生成表达式 上下文 引用表达式 在
  让 值代码 = 生成表达式 上下文 值表达式 在
  "luoyan_ref_set(" ^ 引用代码 ^ ", " ^ 值代码 ^ ")"

(* 生成构造器表达式代码 *)
和 生成构造器表达式 = 函数 上下文 构造器名 参数列表 ->
  让 构造器名称 = 转义标识符 构造器名 在
  匹配 参数列表 与
  | [] -> 
    (* 无参数构造器，创建一个带有构造器名的记录 *)
    "luoyan_constructor_create(\"" ^ 构造器名称 ^ "\", NULL)"
  | _ ->
    让 参数代码 = 列表_映射 (生成表达式 上下文) 参数列表 在
    让 参数数组 = 字符串_连接 ", " 参数代码 在
    "luoyan_constructor_create(\"" ^ 构造器名称 ^ "\", luoyan_array_from_values(" ^ 参数数组 ^ "))"

(* 生成序列表达式代码 *)
和 生成序列表达式 = 函数 上下文 表达式列表 ->
  匹配 表达式列表 与
  | [] -> "luoyan_unit()"
  | [表达式] -> 生成表达式 上下文 表达式
  | _ ->
    让 表达式代码列表 = 列表_映射 (生成表达式 上下文) 表达式列表 在
    let 最后一个 = 列表_最后一个 表达式代码列表 在
    let 前面的 = 列表_去掉最后一个 表达式代码列表 在
    "({ " ^ (字符串_连接 "; " 前面的) ^ "; " ^ 最后一个 ^ "; })"

(* 生成语句代码 *)
让 生成语句 = 函数 上下文 语句 ->
  匹配 语句 与
  | 表达式语句 表达式 -> 
    让 表达式代码 = 生成表达式 上下文 表达式 在
    表达式代码 ^ ";"
  | 让绑定语句 (变量, 表达式, _) ->
    让 表达式代码 = 生成表达式 上下文 表达式 在
    让 转义变量 = 转义标识符 变量 在
    "luoyan_env_bind(env, \"" ^ 转义变量 ^ "\", " ^ 表达式代码 ^ ");"
  | 递归让绑定语句 (变量, 表达式, _) ->
    (* 递归函数需要特殊处理 *)
    让 转义变量 = 转义标识符 变量 在
    让 表达式代码 = 生成表达式 上下文 表达式 在
    "luoyan_env_bind(env, \"" ^ 转义变量 ^ "\", luoyan_unit()); " ^
    "luoyan_env_bind(env, \"" ^ 转义变量 ^ "\", " ^ 表达式代码 ^ ");"
  | 类型定义语句 _ -> "/* 类型定义在C生成中被忽略 */"
  | 异常定义语句 (_, _, _) -> "/* 异常定义在C生成中被忽略 */"

(* 生成程序代码 *)
让 生成程序 = 函数 上下文 程序 ->
  让 递归 生成语句列表 = 函数 语句列表 ->
    匹配 语句列表 与
    | [] -> ""
    | 语句 :: 剩余 ->
      让 语句代码 = 生成语句 上下文 语句 在
      语句代码 ^ "\n" ^ (生成语句列表 剩余)
  在
  生成语句列表 程序

(* 生成完整的C代码 *)
让 生成C代码 = 函数 配置 程序 ->
  让 上下文 = 创建上下文 配置 在
  
  (* 生成主要代码 *)
  让 主代码 = 生成程序 上下文 程序 在
  
  (* 生成完整的C文件 *)
  让 包含文件 = 字符串_连接 "\n" (列表_映射 (函数 文件 -> "#include \"" ^ 文件 ^ "\"") 上下文.包含文件) 在
  让 函数定义 = 字符串_连接 "\n\n" (反向 上下文.函数定义) 在
  
  让 转义打印 = 转义标识符 "打印" 在
  让 转义读取 = 转义标识符 "读取" 在
  包含文件 ^ "\n\n" ^
  函数定义 ^ "\n\n" ^
  "int main() {\n" ^
  "  luoyan_runtime_init();\n" ^
  "  luoyan_env_t* env = luoyan_env_create(NULL);\n" ^
  "  \n" ^
  "  // 添加内置函数\n" ^
  "  luoyan_env_bind(env, \"" ^ 转义打印 ^ "\", luoyan_function_create(luoyan_builtin_print, env, \"打印\"));\n" ^
  "  luoyan_env_bind(env, \"" ^ 转义读取 ^ "\", luoyan_function_create(luoyan_builtin_read, env, \"读取\"));\n" ^
  "  \n" ^
  "  // 用户程序\n" ^
  主代码 ^
  "  \n" ^
  "  luoyan_env_release(env);\n" ^
  "  luoyan_runtime_cleanup();\n" ^
  "  return 0;\n" ^
  "}\n"

(* 主要编译函数 *)
让 编译到C = 函数 配置 程序 ->
  让 C代码 = 生成C代码 配置 程序 在
  
  (* 写入C文件 *)
  让 输出通道 = 打开_输出文件 配置.输出文件 在
  输出_字符串 输出通道 C代码;
  关闭_输出通道 输出通道;
  
  "C代码已生成到: " ^ 配置.输出文件
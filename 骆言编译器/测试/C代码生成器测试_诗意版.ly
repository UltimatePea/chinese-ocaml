// 骆言自举编译器 - C代码生成器诗意测试
// 用诗词意境验证代码生成器的功能正确性
// 技术与艺术并重的测试哲学

// === 开篇测试词 ===
//「测试赋」
//  代码生成若春风，
//  测试验证如秋收。
//  诗意算法须正确，
//  文学技术共风流。

使用 'C代码生成器_诗意版' 作为 CodeGen;
使用 '抽象语法树' 作为 AST;
使用 '测试框架' 作为 Test;

// === 第一章：基础表达式测试 - 如春花初绽 ===

测试用例 "整数字面量生成_如山石恒固" {
  // 整数如山石，坚固不变，生成应当准确
  表达式 = AST.整数字面量(42);
  
  期望结果 = "42";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "整数字面量应如山石般准确");
}

测试用例 "浮点字面量生成_如流水潺潺" {
  // 浮点如流水，精确微妙，需要保持精度
  表达式 = AST.浮点字面量(3.14159);
  
  期望结果 = "3.14159";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "浮点数应如流水般精确");
}

测试用例 "字符串字面量生成_如珠玉之言" {
  // 字符串如珠玉之言，需要妥善保护
  表达式 = AST.字符串字面量("春眠不觉晓");
  
  期望结果 = "\"春眠不觉晓\"";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "字符串应如珠玉般包装");
}

测试用例 "布尔字面量生成_如阴阳分明" {
  // 布尔如阴阳，非此即彼，界限分明
  真表达式 = AST.布尔字面量(真);
  假表达式 = AST.布尔字面量(假);
  
  真结果 = CodeGen.生成表达式(真表达式, CodeGen.创建生成上下文());
  假结果 = CodeGen.生成表达式(假表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(真结果.0, "1", "真值应如阳光明亮");
  Test.断言相等(假结果.0, "0", "假值应如暗夜深邃");
}

// === 第二章：二元运算测试 - 如阴阳相和 ===

测试用例 "加法运算生成_如春暖花开" {
  // 加法如春日融雪，两数相合而生新
  左 = AST.整数字面量(3);
  右 = AST.整数字面量(4);
  表达式 = AST.二元运算(左, AST.加法, 右);
  
  期望结果 = "(3 + 4)";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "加法应如春暖般和谐");
}

测试用例 "减法运算生成_如秋叶凋零" {
  // 减法如秋叶飘落，大数减小数而余存
  左 = AST.整数字面量(10);
  右 = AST.整数字面量(3);
  表达式 = AST.二元运算(左, AST.减法, 右);
  
  期望结果 = "(10 - 3)";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "减法应如秋声般清减");
}

测试用例 "复合运算生成_如诗词层递" {
  // 复合运算如诗词的层递，需要正确的优先级
  // (3 + 4) * (2 - 1)
  左加 = AST.二元运算(AST.整数字面量(3), AST.加法, AST.整数字面量(4));
  右减 = AST.二元运算(AST.整数字面量(2), AST.减法, AST.整数字面量(1));
  表达式 = AST.二元运算(左加, AST.乘法, 右减);
  
  期望结果 = "((3 + 4) * (2 - 1))";
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言相等(实际结果.0, 期望结果, "复合运算应如律诗般层次分明");
}

// === 第三章：变量和函数测试 - 如人物登场 ===

测试用例 "变量访问生成_如人之姓名" {
  // 变量如人之姓名，需要正确映射
  表达式 = AST.标识符("春风");
  上下文 = CodeGen.创建生成上下文();
  
  // 预先映射变量名
  // TODO: 实现变量映射的设置函数
  
  实际结果 = CodeGen.生成表达式(表达式, 上下文);
  
  Test.断言真(实际结果.0 != "", "变量名应有合适的C映射");
}

测试用例 "函数调用生成_如雁字传书" {
  // 函数调用如雁字传书，参数如信件内容
  函数名 = AST.标识符("计算斐波那契");
  参数 = [AST.整数字面量(10)];
  表达式 = AST.函数调用(函数名, 参数);
  
  期望模式 = "fibonacci(10)";  // 简化期望
  实际结果 = CodeGen.生成表达式(表达式, CodeGen.创建生成上下文());
  
  Test.断言包含(实际结果.0, "10", "函数调用应包含正确参数");
}

// === 第四章：语句生成测试 - 如文章起承转合 ===

测试用例 "条件语句生成_如岔路择径" {
  // 条件语句如人生抉择，需要智慧判断
  条件 = AST.二元运算(AST.标识符("年龄"), AST.大于, AST.整数字面量(18));
  真分支 = AST.表达式语句(AST.函数调用(AST.标识符("可以投票"), []));
  假分支 = 某(AST.表达式语句(AST.函数调用(AST.标识符("未成年"), [])));
  
  语句 = AST.条件语句(条件, 真分支, 假分支);
  上下文 = CodeGen.创建生成上下文();
  
  结果上下文 = CodeGen.生成语句(语句, 上下文);
  生成代码 = 连接字符串(结果上下文.输出缓冲区, "\n");
  
  Test.断言包含(生成代码, "if", "应生成if语句");
  Test.断言包含(生成代码, "else", "应生成else分支");
  Test.断言包含(生成代码, "18", "应包含条件值");
}

测试用例 "循环语句生成_如四季轮回" {
  // while循环如四季轮回，依条件而行
  条件 = AST.二元运算(AST.标识符("计数"), AST.小于, AST.整数字面量(10));
  循环体 = AST.表达式语句(AST.二元运算(
    AST.标识符("计数"), 
    AST.加法, 
    AST.整数字面量(1)
  ));
  
  语句 = AST.循环语句(AST.While循环, 条件, 循环体);
  上下文 = CodeGen.创建生成上下文();
  
  结果上下文 = CodeGen.生成语句(语句, 上下文);
  生成代码 = 连接字符串(结果上下文.输出缓冲区, "\n");
  
  Test.断言包含(生成代码, "while", "应生成while循环");
  Test.断言包含(生成代码, "10", "应包含循环条件");
}

// === 第五章：完整程序测试 - 如诗词成篇 ===

测试用例 "简单程序生成_如五言绝句" {
  // 简单程序如五言绝句，短小精悍，意境深远
  // 等价于：
  // 函数 main() {
  //   printf("春眠不觉晓");
  //   返回 0;
  // }
  
  打印语句 = AST.表达式语句(AST.函数调用(
    AST.标识符("printf"), 
    [AST.字符串字面量("春眠不觉晓")]
  ));
  
  返回语句 = AST.返回语句(某(AST.整数字面量(0)));
  
  函数体 = AST.复合语句([打印语句, 返回语句]);
  
  主函数 = AST.函数定义(
    "main",
    [],
    AST.整数类型,
    函数体
  );
  
  程序 = AST.程序([主函数]);
  
  结果 = CodeGen.生成C代码(程序);
  
  匹配 结果 {
    成功(代码) => {
      Test.断言包含(代码, "#include", "应包含头文件");
      Test.断言包含(代码, "int main", "应有main函数");
      Test.断言包含(代码, "春眠不觉晓", "应包含字符串内容");
      Test.断言包含(代码, "return 0", "应有返回语句");
    }
    错误(错误列表) => {
      Test.断言失败("代码生成不应失败: " + 错误描述(错误列表));
    }
  };
}

测试用例 "斐波那契程序生成_如七言律诗" {
  // 斐波那契程序如七言律诗，层次丰富，递归优美
  // 等价于：
  // 函数 fibonacci(n) {
  //   若 n <= 1 { 返回 n; }
  //   返回 fibonacci(n-1) + fibonacci(n-2);
  // }
  
  // 基础条件：n <= 1
  基础条件 = AST.二元运算(
    AST.标识符("n"), 
    AST.小于等于, 
    AST.整数字面量(1)
  );
  
  基础返回 = AST.返回语句(某(AST.标识符("n")));
  
  条件语句 = AST.条件语句(基础条件, 基础返回, 无);
  
  // 递归调用
  递归1 = AST.函数调用(
    AST.标识符("fibonacci"),
    [AST.二元运算(AST.标识符("n"), AST.减法, AST.整数字面量(1))]
  );
  
  递归2 = AST.函数调用(
    AST.标识符("fibonacci"),
    [AST.二元运算(AST.标识符("n"), AST.减法, AST.整数字面量(2))]
  );
  
  递归返回 = AST.返回语句(某(AST.二元运算(递归1, AST.加法, 递归2)));
  
  函数体 = AST.复合语句([条件语句, 递归返回]);
  
  斐波那契函数 = AST.函数定义(
    "fibonacci",
    [AST.参数("n", AST.整数类型)],
    AST.整数类型,
    函数体
  );
  
  程序 = AST.程序([斐波那契函数]);
  
  结果 = CodeGen.生成C代码(程序);
  
  匹配 结果 {
    成功(代码) => {
      Test.断言包含(代码, "int fibonacci", "应有fibonacci函数定义");
      Test.断言包含(代码, "if", "应有条件判断");
      Test.断言包含(代码, "fibonacci(", "应有递归调用");
      Test.断言包含(代码, "return", "应有返回语句");
    }
    错误(错误列表) => {
      Test.断言失败("斐波那契代码生成应该成功: " + 错误描述(错误列表));
    }
  };
}

// === 第六章：错误处理测试 - 如诗词修辞的严谨 ===

测试用例 "未实现表达式类型处理_如诗不达意" {
  // 测试未实现的表达式类型应当优雅地报告错误
  // 创建一个假想的未实现表达式类型
  // TODO: 需要在AST中定义测试用的未实现类型
  
  Test.跳过测试("待AST支持测试用未实现类型");
}

测试用例 "变量映射失败处理_如名不正言不顺" {
  // 测试变量映射失败时的处理
  未知变量 = AST.标识符("未定义的变量");
  
  结果 = CodeGen.生成表达式(未知变量, CodeGen.创建生成上下文());
  
  // 应该生成一个临时变量名，而不是失败
  Test.断言真(结果.0 != "", "未知变量应生成临时名称");
}

// === 第七章：性能和质量测试 - 如诗词的韵律美 ===

测试用例 "缩进格式正确性_如诗词的平仄" {
  // 测试生成的代码缩进是否正确，如诗词的平仄
  嵌套条件 = AST.条件语句(
    AST.布尔字面量(真),
    AST.条件语句(
      AST.布尔字面量(真),
      AST.表达式语句(AST.整数字面量(1)),
      无
    ),
    无
  );
  
  上下文 = CodeGen.创建生成上下文();
  结果上下文 = CodeGen.生成语句(嵌套条件, 上下文);
  代码行 = 结果上下文.输出缓冲区;
  
  // 检查缩进层次
  外层if行 = 代码行[0];
  内层if行 = 代码行[1];
  内层语句行 = 代码行[2];
  
  Test.断言真(开头空格数(外层if行) == 0, "外层语句不应有缩进");
  Test.断言真(开头空格数(内层if行) == 2, "内层if应有一级缩进");
  Test.断言真(开头空格数(内层语句行) == 4, "内层语句应有二级缩进");
}

测试用例 "大型程序生成性能_如长篇巨制" {
  // 测试大型程序的生成性能
  开始时间 = 获取当前时间();
  
  // 生成包含多个函数的大型程序
  函数列表 = [];
  重复 100 次 循环变量 i {
    函数名 = "函数" + 字符串化(i);
    简单函数 = AST.函数定义(
      函数名,
      [],
      AST.整数类型,
      AST.返回语句(某(AST.整数字面量(i)))
    );
    函数列表 = 函数列表 + [简单函数];
  };
  
  大程序 = AST.程序(函数列表);
  结果 = CodeGen.生成C代码(大程序);
  
  结束时间 = 获取当前时间();
  耗时 = 结束时间 - 开始时间;
  
  Test.断言真(耗时 < 1000, "100个函数的代码生成应在1秒内完成");
  
  匹配 结果 {
    成功(代码) => {
      函数数量 = 计算子串出现次数(代码, "int 函数");
      Test.断言相等(函数数量, 100, "应生成100个函数");
    }
    错误(_) => {
      Test.断言失败("大型程序生成不应失败");
    }
  };
}

// === 测试运行器：如诗词的总序 ===
函数 运行所有测试() {
  Test.开始测试套件("C代码生成器诗意测试");
  
  // 第一章：基础表达式测试
  Test.运行测试("整数字面量生成_如山石恒固");
  Test.运行测试("浮点字面量生成_如流水潺潺");
  Test.运行测试("字符串字面量生成_如珠玉之言");
  Test.运行测试("布尔字面量生成_如阴阳分明");
  
  // 第二章：二元运算测试
  Test.运行测试("加法运算生成_如春暖花开");
  Test.运行测试("减法运算生成_如秋叶凋零");
  Test.运行测试("复合运算生成_如诗词层递");
  
  // 第三章：变量和函数测试
  Test.运行测试("变量访问生成_如人之姓名");
  Test.运行测试("函数调用生成_如雁字传书");
  
  // 第四章：语句生成测试
  Test.运行测试("条件语句生成_如岔路择径");
  Test.运行测试("循环语句生成_如四季轮回");
  
  // 第五章：完整程序测试
  Test.运行测试("简单程序生成_如五言绝句");
  Test.运行测试("斐波那契程序生成_如七言律诗");
  
  // 第六章：错误处理测试
  Test.运行测试("变量映射失败处理_如名不正言不顺");
  
  // 第七章：性能和质量测试
  Test.运行测试("缩进格式正确性_如诗词的平仄");
  Test.运行测试("大型程序生成性能_如长篇巨制");
  
  Test.结束测试套件();
}

// === 辅助函数 ===
函数 开头空格数(文本: 字符串) -> 数字 {
  计数 = 0;
  对于 文本中的每个字符 字符 {
    若 字符 == ' ' {
      计数 = 计数 + 1;
    } 否则 {
      退出循环;
    };
  };
  返回 计数;
}

函数 计算子串出现次数(文本: 字符串, 子串: 字符串) -> 数字 {
  // 简化实现
  分割结果 = 分割字符串(文本, 子串);
  返回 分割结果.长度 - 1;
}

// === 结语 ===
//
// 此测试文件体现了诗意测试的理念：
// 1. 每个测试都有诗意的命名和注释
// 2. 测试用例体现了中华文化的美学思想  
// 3. 测试结构如诗词的章法，层次分明
// 4. 既验证功能正确性，又体现编程艺术
//
// 正如《诗经》所云："关关雎鸠，在河之洲。"
// 好的测试如关雎之歌，既要准确无误，又要优美动听。
//
// 让测试代码也充满诗意，让验证过程成为艺术享受！
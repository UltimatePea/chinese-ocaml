# 严格引用标识符语法实施

## 项目概述

根据问题 #28 和 #30 的指导，实施严格的「」引用标识符语法，建立清晰的对象级别/元级别区分。

## 设计目标

### 核心原则
- **对象级别标识符**：所有用户定义的名称必须用「」包围
- **元级别关键字**：语言的语法关键字不使用「」，直接使用
- **完全迁移**：移除对非引用标识符的支持，不考虑向后兼容

### 语法对比

**当前混合模式**：
```luoyan
let variable = 42
函数 factorial n = if n <= 1 then 1 else n * factorial (n - 1)
```

**目标严格模式**：
```luoyan
让「变量」= 42
函数「阶乘」「n」= 如果「n」<= 1 那么 1 否则「n」*「阶乘」(「n」- 1)
```

## 技术实施计划

### 阶段1：词法分析器修改
- [x] 移除 `IdentifierToken` 的生成逻辑
- [x] 只保留 `QuotedIdentifierToken` 支持
- [x] 更新错误消息，提示使用引用语法

### 阶段2：语法分析器重构
- [ ] 修改 `parse_identifier` 只接受 `QuotedIdentifierToken`
- [ ] 移除 `parse_identifier_allow_keywords` 中的关键字处理
- [ ] 更新所有使用标识符的解析函数

### 阶段3：测试和示例更新
- [ ] 更新所有测试文件使用新语法
- [ ] 更新示例程序
- [ ] 确保所有功能正常工作

### 阶段4：文档更新
- [ ] 更新语言规范
- [ ] 添加迁移指南
- [ ] 记录设计决策

## 具体实施

### 1. 词法分析器修改

移除 `read_identifier_utf8` 函数中生成普通标识符的逻辑：

```ocaml
(* 修改前 *)
(IdentifierToken identifier, pos, temp_state)

(* 修改后 *)
raise (LexError ("标识符必须使用引用语法「标识符」", pos))
```

### 2. 语法分析器修改

简化 `parse_identifier` 函数：

```ocaml
let parse_identifier state =
  let (token, pos) = current_token state in
  match token with
  | QuotedIdentifierToken name -> (name, advance_parser state)
  | _ -> raise (SyntaxError ("期望引用标识符「名称」，但遇到 " ^ show_token token, pos))
```

### 3. 关键字处理

保留的元级别关键字（不需要引用）：
- 让、函数、如果、那么、否则
- 匹配、与、类型、模块
- 尝试、捕获、抛出、异常
- 真、假、并且、或者、非
- 等等所有语法关键字

### 4. 测试文件示例转换

**test_basic.ly 修改前**：
```luoyan
let x = 42
let result = factorial 5
```

**test_basic.ly 修改后**：
```luoyan
让「x」= 42
让「结果」=「阶乘」5
```

## 预期影响

### 优势
1. **完全消除歧义**：再无关键字与标识符冲突
2. **语法一致性**：清晰的元级别/对象级别区分
3. **AI友好性**：机器更容易理解语法结构
4. **扩展性**：可以自由添加新关键字

### 挑战
1. **重大变更**：所有现有代码需要重写
2. **输入体验**：需要频繁输入「」字符
3. **视觉密度**：代码可能看起来更密集

### 缓解措施
1. 专注于AI编程场景，不考虑人工输入便利性
2. 提供清晰的错误消息指导迁移
3. 创建示例代码展示新语法的优雅性

## 时间表

- **Week 1**: 词法分析器和语法分析器核心修改
- **Week 2**: 测试文件全面更新
- **Week 3**: 文档更新和验证
- **Week 4**: 性能优化和完善

## 风险评估

**高风险**：
- 可能破坏现有的所有测试和示例
- 需要大量的测试用例更新

**缓解策略**：
- 逐步修改，每次提交都确保基本功能可用
- 优先修复核心功能，然后扩展到高级特性

---

此实施计划将彻底改变骆言的语法哲学，建立更清晰、更一致的编程体验。
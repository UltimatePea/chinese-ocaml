# 骆言项目长函数分析报告\n\n## lexer_variants.ml:7 - convert_basic_keywords()\n- **行数**: 249\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:29 - convert_semantic_keywords()\n- **行数**: 229\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:38 - convert_exception_keywords()\n- **行数**: 222\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:47 - convert_module_keywords()\n- **行数**: 215\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:58 - convert_macro_keywords()\n- **行数**: 206\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:64 - convert_wenyan_keywords()\n- **行数**: 202\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:87 - convert_ancient_keywords()\n- **行数**: 181\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:136 - convert_natural_keywords()\n- **行数**: 135\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:164 - convert_type_keywords()\n- **行数**: 109\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 🚨 函数过长，建议拆分为多个较小的函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:177 - convert_poetry_keywords()\n- **行数**: 98\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## value_operations.ml:60 - available_vars()\n- **行数**: 95\n- **复杂度**: 模式匹配 12, 条件分支 2\n- **建议**:\n  - 🔄 考虑将复杂的模式匹配分解为独立的辅助函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n  - 📋 大量列表操作，考虑使用更高效的数据结构\n\n## lexer_token_conversion_classical.ml:6 - convert_wenyan_token()\n- **行数**: 91\n- **复杂度**: 模式匹配 0, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## lexer/token_mapping/classical_token_mapping.ml:6 - map_wenyan_variant()\n- **行数**: 85\n- **复杂度**: 模式匹配 0, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## parser_expressions_main.ml:4 - parse_expression()\n- **行数**: 77\n- **复杂度**: 模式匹配 2, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## codegen.ml:70 - try_to_string()\n- **行数**: 75\n- **复杂度**: 模式匹配 7, 条件分支 0\n- **建议**:\n  - 🔄 考虑将复杂的模式匹配分解为独立的辅助函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:203 - convert_special_identifier()\n- **行数**: 74\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## codegen.ml:71 - value_to_bool()\n- **行数**: 74\n- **复杂度**: 模式匹配 7, 条件分支 0\n- **建议**:\n  - 🔄 考虑将复杂的模式匹配分解为独立的辅助函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## codegen.ml:74 - execute_stmt()\n- **行数**: 73\n- **复杂度**: 模式匹配 7, 条件分支 0\n- **建议**:\n  - 🔄 考虑将复杂的模式匹配分解为独立的辅助函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_variants.ml:208 - convert_core_keywords()\n- **行数**: 71\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_token_conversion_classical.ml:29 - convert_natural_language_token()\n- **行数**: 70\n- **复杂度**: 模式匹配 0, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## types_convert.ml:184 - basic_type_to_chinese()\n- **行数**: 65\n- **复杂度**: 模式匹配 2, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer/token_mapping/classical_token_mapping.ml:31 - map_ancient_variant()\n- **行数**: 64\n- **复杂度**: 模式匹配 0, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## lexer_variants.ml:222 - convert_system_keywords()\n- **行数**: 61\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## types_convert.ml:193 - container_type_to_chinese()\n- **行数**: 58\n- **复杂度**: 模式匹配 2, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## error_recovery.ml:83 - distances()\n- **行数**: 56\n- **复杂度**: 模式匹配 3, 条件分支 8\n- **建议**:\n  - 🔀 条件分支过多，考虑使用查找表或策略模式\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## error_recovery.ml:84 - sorted()\n- **行数**: 55\n- **复杂度**: 模式匹配 3, 条件分支 8\n- **建议**:\n  - 🔀 条件分支过多，考虑使用查找表或策略模式\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## interpreter_utils.ml:47 - member_name()\n- **行数**: 53\n- **复杂度**: 模式匹配 4, 条件分支 0\n- **建议**:\n  - 🔄 考虑将复杂的模式匹配分解为独立的辅助函数\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n  - 📋 大量列表操作，考虑使用更高效的数据结构\n\n## lexer_variants.ml:236 - convert_chinese_style_keywords()\n- **行数**: 52\n- **复杂度**: 模式匹配 1, 条件分支 0\n- **建议**:\n  - ✅ 函数结构相对合理，可考虑添加更多注释说明\n\n## types_convert.ml:201 - construct_type_to_chinese()\n- **行数**: 52\n- **复杂度**: 模式匹配 2, 条件分支 0\n- **建议**:\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n## lexer_utils.ml:319 - final_state()\n- **行数**: 52\n- **复杂度**: 模式匹配 1, 条件分支 18\n- **建议**:\n  - 🔀 条件分支过多，考虑使用查找表或策略模式\n  - 📦 嵌套函数过多，考虑将部分函数提取到模块级别\n\n
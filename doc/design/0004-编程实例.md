# 骆言编程实例

## 基础示例

### Hello World
```ocaml
让 问候语 = "你好，世界！"
打印 问候语
```

### 基本算术
```ocaml
让 加法 = 函数 a b -> a + b
让 减法 = 函数 a b -> a - b
让 乘法 = 函数 a b -> a * b
让 除法 = 函数 a b ->
  如果 b == 0 那么 错误 "除零错误"
  否则 a / b

让 结果1 = 加法 10 5      // 15
让 结果2 = 乘法 3 4       // 12
让 结果3 = 除法 20 4      // 5
```

### 条件判断
```ocaml
让 判断正负 = 函数 数字 ->
  如果 数字 > 0 那么 "正数"
  否则 如果 数字 < 0 那么 "负数"
  否则 "零"

让 分类 = 判断正负 (-5)  // "负数"
```

## 函数式编程示例

### 递归函数
```ocaml
让 递归 阶乘 = 函数 n ->
  如果 n <= 1 那么 1
  否则 n * 阶乘 (n - 1)

让 递归 斐波那契 = 函数 n ->
  如果 n <= 1 那么 n
  否则 斐波那契 (n - 1) + 斐波那契 (n - 2)

让 结果 = 阶乘 5         // 120
让 斐波 = 斐波那契 8      // 21
```

### 高阶函数
```ocaml
让 递归 映射 = 函数 f 列表 ->
  匹配 列表 与
  | [] -> []
  | 头 :: 尾 -> (f 头) :: (映射 f 尾)

让 递归 过滤 = 函数 条件 列表 ->
  匹配 列表 与
  | [] -> []
  | 头 :: 尾 ->
    如果 条件 头 那么 头 :: (过滤 条件 尾)
    否则 过滤 条件 尾

让 递归 折叠 = 函数 f 初值 列表 ->
  匹配 列表 与
  | [] -> 初值
  | 头 :: 尾 -> 折叠 f (f 初值 头) 尾

// 使用示例
让 数字列表 = [1; 2; 3; 4; 5]
让 平方列表 = 映射 (函数 x -> x * x) 数字列表  // [1; 4; 9; 16; 25]
让 偶数列表 = 过滤 (函数 x -> x % 2 == 0) 数字列表  // [2; 4]
让 总和 = 折叠 (+) 0 数字列表  // 15
```

## 数据结构示例

### 列表操作
```ocaml
让 列表1 = [1; 2; 3]
让 列表2 = 0 :: 列表1        // [0; 1; 2; 3]
让 列表3 = 列表1 @ [4; 5]    // [1; 2; 3; 4; 5]

让 递归 长度 = 函数 列表 ->
  匹配 列表 与
  | [] -> 0
  | _ :: 尾 -> 1 + 长度 尾

让 递归 反转 = 函数 列表 ->
  让 递归 辅助 = 函数 原列表 累积 ->
    匹配 原列表 与
    | [] -> 累积
    | 头 :: 尾 -> 辅助 尾 (头 :: 累积)
  在 辅助 列表 []

让 列表长度 = 长度 [1; 2; 3; 4]  // 4
让 反转列表 = 反转 [1; 2; 3]     // [3; 2; 1]
```

### 自定义数据类型
```ocaml
类型 颜色 = 红色 | 绿色 | 蓝色 | RGB of int * int * int

类型 形状 =
  | 圆形 of float
  | 矩形 of float * float
  | 三角形 of float * float * float

让 计算面积 = 函数 形状 ->
  匹配 形状 与
  | 圆形 半径 -> 3.14159 * 半径 * 半径
  | 矩形 (长, 宽) -> 长 * 宽
  | 三角形 (a, b, c) ->
    让 s = (a + b + c) / 2.0 在
    sqrt (s * (s - a) * (s - b) * (s - c))

// 使用示例
让 我的圆 = 圆形 5.0
让 我的矩形 = 矩形 (3.0, 4.0)
让 圆面积 = 计算面积 我的圆      // 78.54
让 矩形面积 = 计算面积 我的矩形   // 12.0
```

### 二叉树
```ocaml
类型 'a 二叉树 = 空树 | 节点 of 'a * 'a 二叉树 * 'a 二叉树

让 递归 插入 = 函数 值 树 ->
  匹配 树 与
  | 空树 -> 节点 (值, 空树, 空树)
  | 节点 (根值, 左子树, 右子树) ->
    如果 值 < 根值 那么 节点 (根值, 插入 值 左子树, 右子树)
    否则 如果 值 > 根值 那么 节点 (根值, 左子树, 插入 值 右子树)
    否则 树

让 递归 中序遍历 = 函数 树 ->
  匹配 树 与
  | 空树 -> []
  | 节点 (值, 左子树, 右子树) ->
    (中序遍历 左子树) @ [值] @ (中序遍历 右子树)

// 构建二叉搜索树
让 空的树 = 空树
让 树1 = 插入 5 空的树
让 树2 = 插入 3 树1
让 树3 = 插入 7 树2
让 树4 = 插入 1 树3
让 有序列表 = 中序遍历 树4  // [1; 3; 5; 7]
```

## 模式匹配示例

### 复杂模式匹配
```ocaml
类型 表达式 =
  | 数字 of int
  | 变量 of string
  | 加法 of 表达式 * 表达式
  | 乘法 of 表达式 * 表达式
  | 函数调用 of string * 表达式 list

让 递归 简化 = 函数 表达式 ->
  匹配 表达式 与
  | 加法 (数字 0, e) -> 简化 e
  | 加法 (e, 数字 0) -> 简化 e
  | 乘法 (数字 1, e) -> 简化 e
  | 乘法 (e, 数字 1) -> 简化 e
  | 乘法 (数字 0, _) -> 数字 0
  | 乘法 (_, 数字 0) -> 数字 0
  | 加法 (数字 a, 数字 b) -> 数字 (a + b)
  | 乘法 (数字 a, 数字 b) -> 数字 (a * b)
  | 加法 (e1, e2) -> 加法 (简化 e1, 简化 e2)
  | 乘法 (e1, e2) -> 乘法 (简化 e1, 简化 e2)
  | e -> e

// 测试表达式简化
让 表达式1 = 加法 (数字 0, 乘法 (数字 2, 数字 3))
让 简化后 = 简化 表达式1  // 数字 6
```

### 列表模式匹配
```ocaml
让 分析列表 = 函数 列表 ->
  匹配 列表 与
  | [] -> "空列表"
  | [x] -> "单元素列表: " ^ (字符串化 x)
  | [x; y] -> "双元素列表: " ^ (字符串化 x) ^ ", " ^ (字符串化 y)
  | x :: y :: _ -> "多元素列表，前两个: " ^ (字符串化 x) ^ ", " ^ (字符串化 y)

让 结果1 = 分析列表 []        // "空列表"
让 结果2 = 分析列表 [42]      // "单元素列表: 42"
让 结果3 = 分析列表 [1; 2; 3; 4]  // "多元素列表，前两个: 1, 2"
```

## 实用程序示例

### 排序算法
```ocaml
让 递归 快速排序 = 函数 列表 ->
  匹配 列表 与
  | [] -> []
  | 基准 :: 剩余 ->
    让 (小于等于, 大于) = 分割 (函数 x -> x <= 基准) 剩余 在
    (快速排序 小于等于) @ [基准] @ (快速排序 大于)

让 递归 分割 = 函数 条件 列表 ->
  匹配 列表 与
  | [] -> ([], [])
  | 头 :: 尾 ->
    让 (真列表, 假列表) = 分割 条件 尾 在
    如果 条件 头 那么 (头 :: 真列表, 假列表)
    否则 (真列表, 头 :: 假列表)

让 无序列表 = [3; 1; 4; 1; 5; 9; 2; 6]
让 有序列表 = 快速排序 无序列表  // [1; 1; 2; 3; 4; 5; 6; 9]
```

### 文本处理
```ocaml
让 递归 单词计数 = 函数 文本 ->
  让 单词列表 = 分割字符串 ' ' 文本 在
  让 非空单词 = 过滤 (函数 s -> 字符串长度 s > 0) 单词列表 在
  长度 非空单词

让 统计字符 = 函数 字符 文本 ->
  让 字符列表 = 字符串转列表 文本 在
  长度 (过滤 (函数 c -> c == 字符) 字符列表)

让 示例文本 = "你好 世界 骆言 编程"
让 单词数 = 单词计数 示例文本     // 4
让 空格数 = 统计字符 ' ' 示例文本  // 3
```

这些示例展示了骆言语言的表达能力和灵活性，涵盖了从基础语法到高级特性的各个方面。通过这些实例，AI开发者可以快速掌握如何使用骆言进行有效编程。
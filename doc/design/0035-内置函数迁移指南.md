# 骆言内置函数迁移到标准库指南

## 概述

本文档描述了将现有内置函数逐步迁移到标准库模块的详细计划和实施步骤。这一迁移将使骆言编程语言更加模块化和易于维护。

## 迁移目标

### 1. 提高代码组织性
- 将相关功能分组到逻辑模块中
- 减少编译器核心的复杂性
- 提供清晰的功能边界

### 2. 增强可扩展性
- 新功能可以作为标准库模块添加
- 第三方可以贡献标准库模块
- 支持选择性导入功能

### 3. 改善维护性
- 每个模块可以独立测试和维护
- 错误隔离到特定模块
- 版本控制更精细

## 当前内置函数分析

### 已识别的内置函数

从 `src/semantic.ml` 分析得出的现有内置函数：

#### IO函数
- `打印`: 通用打印函数
- `读取`: 标准输入读取

#### 列表函数
- `长度`: 计算列表长度
- `连接`: 列表连接
- `过滤`: 列表过滤
- `映射`: 列表映射
- `折叠`: 列表折叠

#### 数组函数
- `数组长度`: 计算数组长度
- `数组获取`: 数组元素访问
- `数组设置`: 数组元素设置

#### 字符串函数
- `字符串长度`: 计算字符串长度
- `字符串连接`: 字符串连接

## 迁移策略

### 阶段1: 建立标准库基础架构 ✅

**已完成**:
- 创建标准库目录结构
- 实现核心模块（基础、数学、列表、字符串）
- 建立模块导入机制
- 创建测试框架

### 阶段2: 迁移基础函数 (当前阶段)

**目标函数**:
- `打印` → `输入输出.打印`
- `读取` → `输入输出.读取`
- `长度` → `列表.长度` / `字符串.长度`

**实施步骤**:
1. 在标准库中实现对应函数
2. 修改编译器以支持标准库调用
3. 保留内置函数作为别名（向后兼容）
4. 更新文档和示例

### 阶段3: 迁移高级函数

**目标函数**:
- `映射` → `列表.映射`
- `过滤` → `列表.过滤`
- `折叠` → `列表.折叠左` / `列表.折叠右`
- `连接` → `列表.连接` / `字符串.连接`

### 阶段4: 迁移专门函数

**目标函数**:
- 数组相关函数 → `数组` 模块
- 文件操作函数 → `文件系统` 模块
- 网络函数 → `网络` 模块

### 阶段5: 清理和优化

- 移除冗余的内置函数
- 优化标准库性能
- 完善错误处理
- 更新所有文档

## 具体迁移计划

### 1. IO模块创建

```luoyan
模块 输入输出 = {
  导出: [
    ("打印", 函数类型 (类型变量 "a", 单元类型));
    ("打印行", 函数类型 (类型变量 "a", 单元类型));
    ("读取", 函数类型 (单元类型, 字符串类型));
    ("读取行", 函数类型 (单元类型, 字符串类型));
  ];
  
  语句: [
    让 打印 = 内置函数 "print";
    让 打印行 = 内置函数 "print_endline";
    让 读取 = 内置函数 "read";
    让 读取行 = 内置函数 "read_line";
  ];
}
```

### 2. 编译器修改

#### 在 `semantic.ml` 中:
```ocaml
(* 新增标准库模块支持 *)
let add_stdlib_modules context =
  let stdlib_modules = [
    ("基础", load_module "stdlib/基础.luoyan");
    ("数学", load_module "stdlib/数学.luoyan");
    ("列表", load_module "stdlib/列表.luoyan");
    ("字符串", load_module "stdlib/字符串.luoyan");
    ("输入输出", load_module "stdlib/输入输出.luoyan");
  ] in
  List.fold_left add_module_to_context context stdlib_modules
```

#### 在 `codegen.ml` 中:
```ocaml
(* 标准库函数调用处理 *)
let eval_stdlib_call module_name func_name args =
  match (module_name, func_name) with
  | ("输入输出", "打印") -> eval_builtin_print args
  | ("列表", "长度") -> eval_builtin_length args
  | _ -> raise (RuntimeError ("未知标准库函数: " ^ module_name ^ "." ^ func_name))
```

### 3. 向后兼容性

保持现有代码正常工作的策略：

```ocaml
(* 在 semantic.ml 中保留别名 *)
let add_compatibility_aliases context =
  let aliases = [
    ("打印", "输入输出.打印");
    ("长度", "列表.长度");
    ("映射", "列表.映射");
  ] in
  List.fold_left add_alias context aliases
```

## 测试策略

### 1. 兼容性测试

确保现有代码继续工作：
```luoyan
(* 旧式写法应该继续工作 *)
让 列表长度 = 长度 [1; 2; 3; 4; 5];
打印 列表长度;

(* 新式写法也应该工作 *)
导入 列表: [长度];
导入 输入输出: [打印];
让 列表长度 = 长度 [1; 2; 3; 4; 5];
打印 列表长度;
```

### 2. 性能测试

确保标准库调用性能不降低：
```luoyan
(* 性能基准测试 *)
让 大列表 = 范围 1 10000;
让 开始时间 = 获取时间 ();
让 结果 = 映射 (函数 x -> x * x) 大列表;
让 结束时间 = 获取时间 ();
打印 ("映射操作耗时: " + 浮点转字符串 (结束时间 - 开始时间) + "秒");
```

### 3. 错误处理测试

确保错误消息清晰有用：
```luoyan
(* 错误处理测试 *)
尝试 {
  导入 不存在模块: [某函数];
} 捕获 异常 -> {
  打印 "期望的错误：模块不存在";
};
```

## 实施时间表

### 第1周: 基础设施
- ✅ 完成标准库基础模块
- ✅ 建立测试框架
- ✅ 创建文档

### 第2周: 核心迁移
- 🔄 实现IO模块
- 🔄 修改编译器支持标准库
- 🔄 建立兼容性层

### 第3周: 扩展迁移
- 📋 迁移数组函数
- 📋 迁移高级列表函数
- 📋 性能优化

### 第4周: 完善和清理
- 📋 移除冗余内置函数
- 📋 完善文档
- 📋 最终测试

## 风险和缓解策略

### 风险1: 性能回退
**缓解**: 建立性能基准测试，确保标准库调用开销最小

### 风险2: 向后兼容性破坏
**缓解**: 保留别名机制，逐步过渡而非强制迁移

### 风险3: 增加复杂性
**缓解**: 清晰的模块划分，充分的文档和示例

### 风险4: 调试困难
**缓解**: 保留详细的错误信息，增强调试工具

## 成功指标

### 1. 功能完整性
- 所有现有功能在标准库中可用
- 新功能容易添加

### 2. 性能保持
- 标准库函数性能与内置函数相当
- 内存使用合理

### 3. 可用性提升
- 代码更易组织和维护
- 错误信息更清晰
- 文档更完善

### 4. 生态系统健康
- 第三方模块容易集成
- 社区贡献更容易
- 测试覆盖完整

## 结论

通过这个系统性的迁移计划，骆言编程语言将获得：
- 更清晰的代码组织
- 更强的可扩展性
- 更好的维护性
- 更丰富的功能生态

迁移过程将保持向后兼容性，确保现有代码继续工作，同时为未来发展奠定坚实基础。
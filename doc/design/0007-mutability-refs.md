# 可变性与引用类型设计文档

## 概述

本文档设计骆言编程语言的可变性支持，主要通过引用类型（References）实现。这是OCaml中的核心特性，允许创建可变的数据结构。

## 设计动机

### 为什么需要可变性？

1. **算法实现**：某些算法（如图算法、动态规划）需要就地修改数据
2. **性能优化**：避免频繁的数据复制
3. **状态管理**：程序中需要维护全局或局部状态
4. **OCaml兼容性**：保持与OCaml的特性对等

### AI友好的设计考虑

1. **明确的可变标识**：使用中文关键字`引用`使可变性一目了然
2. **类型安全**：编译时检查引用类型的正确使用
3. **简洁语法**：减少AI代理编程时的语法错误

## 语法设计

### 引用创建
```
让 计数器 = 引用 0
让 名字 = 引用 "张三"
让 列表 = 引用 [1; 2; 3]
```

### 引用取值（解引用）
```
让 当前值 = !计数器
打印 (!名字)
```

### 引用赋值
```
计数器 := 42
名字 := "李四"
列表 := [4; 5; 6]
```

### 在表达式中使用
```
让 递增 = 函数 r ->
  r := !r + 1

让 交换 = 函数 a -> 函数 b ->
  让 临时 = !a 在
  a := !b;
  b := 临时
```

## AST扩展

### 新增表达式类型
```ocaml
type expr = 
  | ...
  | RefExpr of expr                    (* 引用 expr *)
  | DerefExpr of expr                  (* !expr *)
  | AssignExpr of expr * expr          (* expr := expr *)
```

### 新增类型
```ocaml
type luoyan_type =
  | ...
  | RefType of luoyan_type             (* 引用类型 *)
```

## 运行时实现

### 引用值类型
```ocaml
type runtime_value = 
  | ...
  | RefValue of runtime_value ref      (* 可变引用 *)
```

### 内置函数
- `引用` - 创建新引用
- `!` - 解引用操作符
- `:=` - 赋值操作符

## 词法分析器更新

### 新增关键字
- `引用` (RefKeyword) - 创建引用

### 新增操作符
- `!` (Bang) - 解引用
- `:=` (Assign) - 引用赋值

## 语法分析器更新

### 解析函数
1. `parse_ref_expression` - 解析引用创建
2. `parse_deref_expression` - 解析解引用
3. `parse_assign_expression` - 解析赋值

### 操作符优先级
- `!` - 高优先级（前缀操作符）
- `:=` - 低优先级（赋值操作符）

## 类型系统更新

### 类型推断规则
1. `引用 e : τ` ⇒ `ref τ`
2. `!e : ref τ` ⇒ `τ`
3. `e1 := e2 : ref τ × τ` ⇒ `unit`

### 类型检查
```ocaml
let infer_ref_expr env expr =
  let (subst, expr_type) = infer_type env expr in
  (subst, RefType expr_type)

let infer_deref_expr env expr =
  let (subst, expr_type) = infer_type env expr in
  match expr_type with
  | RefType inner_type -> (subst, inner_type)
  | _ -> raise (TypeError "解引用操作需要引用类型")
```

## 代码生成更新

### 运行时操作
```ocaml
let eval_ref_expr env expr =
  let value = eval_expr env expr in
  RefValue (ref value)

let eval_deref_expr env expr =
  match eval_expr env expr with
  | RefValue r -> !r
  | _ -> raise (RuntimeError "解引用操作需要引用值")

let eval_assign_expr env target_expr value_expr =
  match eval_expr env target_expr with
  | RefValue r -> 
    let new_value = eval_expr env value_expr in
    r := new_value;
    UnitValue
  | _ -> raise (RuntimeError "赋值目标必须是引用")
```

## 示例程序

### 计数器实现
```
让 创建计数器 = 函数 初值 ->
  让 计数 = 引用 初值 在
  {
    获取 = 函数 () -> !计数;
    递增 = 函数 () -> 计数 := !计数 + 1;
    递减 = 函数 () -> 计数 := !计数 - 1;
    重置 = 函数 新值 -> 计数 := 新值;
  }

让 计数器 = 创建计数器 0
计数器.递增 ()
计数器.递增 ()
打印 (计数器.获取 ())  (* 输出: 2 *)
```

### 可变列表操作
```
让 可变列表 = 引用 [1; 2; 3]

让 添加元素 = 函数 列表引用 -> 函数 元素 ->
  列表引用 := 元素 :: (!列表引用)

添加元素 可变列表 0
打印 (!可变列表)  (* 输出: [0; 1; 2; 3] *)
```

### 状态机实现
```
类型 状态 = 开始 | 运行 | 停止

让 状态机 = 引用 开始

让 转换状态 = 函数 新状态 ->
  打印 ("从" ^ 显示状态 (!状态机) ^ "转换到" ^ 显示状态 新状态);
  状态机 := 新状态

转换状态 运行
转换状态 停止
```

## 测试用例

### 基础操作测试
1. 引用创建和解引用
2. 引用赋值
3. 类型检查

### 高级用例测试
1. 引用在函数中的传递
2. 引用的引用（嵌套引用）
3. 引用与其他数据结构的结合

### 错误处理测试
1. 对非引用值解引用
2. 对非引用值赋值
3. 类型不匹配的赋值

## 实现计划

### 第一阶段：基础实现
1. 扩展词法分析器（关键字和操作符）
2. 扩展AST定义
3. 实现基础语法分析

### 第二阶段：语义分析
1. 扩展类型系统
2. 实现类型推断
3. 添加错误检查

### 第三阶段：运行时支持
1. 实现运行时引用值
2. 实现求值函数
3. 添加内置函数

### 第四阶段：测试和文档
1. 编写全面的测试用例
2. 性能测试
3. 更新用户文档

## 兼容性考虑

### OCaml对比
| OCaml | 骆言 | 说明 |
|-------|------|------|
| `ref 42` | `引用 42` | 创建引用 |
| `!r` | `!r` | 解引用 |
| `r := 10` | `r := 10` | 赋值 |

### 向后兼容性
- 现有代码不受影响
- 新特性是可选的
- 不影响现有类型系统

## 潜在问题和解决方案

### 问题1：循环引用
**解决方案**：引用本身不会造成内存泄漏，但需要注意数据结构设计

### 问题2：并发访问
**解决方案**：当前是单线程实现，未来可考虑添加锁机制

### 问题3：性能影响
**解决方案**：引用操作应该是O(1)的，不会显著影响性能

## 总结

引用类型的实现将为骆言语言添加重要的可变性支持，使其更接近完整的OCaml功能集。这个特性对AI友好，语法清晰，实现相对简单，是下一个开发重点。
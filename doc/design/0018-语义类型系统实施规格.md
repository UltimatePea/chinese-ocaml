# 语义类型系统实施规格

**文档编号**: 0002  
**日期**: 2025-07-12  
**状态**: 设计中  
**作者**: Claude AI  
**依赖**: [0001-ai优先语言特性设计.md](0001-ai优先语言特性设计.md)

## 概述

语义类型系统是骆言编译器AI友好特性的第一个重要特性。目标是让AI能够使用更自然的中文语义来描述类型关系，而不是严格的类型语法。

## 目标语法

### 基础语义类型标注
```chinese
# 当前语法 - 严格类型
让 年龄: 整数 = 25
让 姓名: 字符串 = "张三"

# 新语法 - 语义类型  
让 年龄 作为 人员信息 = 25
让 姓名 作为 人员信息 = "张三"
让 身高 作为 人员信息 = 175.5
```

### 语义类型组合
```chinese
# 自动推断结构类型
让 人员 = 组合 年龄 以及 姓名 以及 身高

# 等价于创建一个包含三个字段的结构
# { 年龄: 整数, 姓名: 字符串, 身高: 浮点数 }
```

### 语义类型匹配
```chinese
# 基于语义标签的模式匹配
匹配 人员 与
| 组合 young_age 以及 name 以及 height 当 young_age < 30 -> 
    打印 name + " 是年轻人"
| 组合 age 以及 name 以及 _ ->
    打印 name + " 年龄: " + age
```

## 语言扩展规格

### 1. 新增关键字
- `作为` (as) - 语义类型标注
- `组合` (combine) - 类型组合操作  
- `以及` (with_op) - 组合连接符
- `当` (when) - 条件守卫

### 2. 词法分析器扩展
```ocaml
(* 在 lexer.ml 中添加新的关键字 *)
| "作为" -> AS
| "组合" -> COMBINE  
| "和" -> AND_OP
| "当" -> WHEN
```

### 3. 语法分析器扩展

#### AST节点扩展
```ocaml
(* 在 ast.ml 中添加语义类型相关节点 *)
type semantic_type = 
  | SemanticLabel of string (* 语义标签，如 "人员信息" *)
  | CombinedType of semantic_type list (* 组合类型 *)

type expr = 
  (* 现有表达式... *)
  | SemanticLetExpr of string * semantic_type * expr * expr
  | CombineExpr of expr list
  (* ... *)

type stmt =
  (* 现有语句... *)  
  | SemanticLetStmt of string * semantic_type * expr
  (* ... *)
```

#### 语法规则扩展
```ocaml
(* 在 parser.ml 中添加语义类型解析 *)
let parse_semantic_let state = 
  (* 解析: 让 变量名 作为 语义标签 = 表达式 *)
  ...

let parse_combine_expr state =
  (* 解析: 组合 表达式1 和 表达式2 和 ... *)
  ...
```

### 4. 语义分析扩展

#### 语义类型推断
```ocaml
(* 在 semantic.ml 中添加语义类型处理 *)
type semantic_context = {
  semantic_groups: (string, (string * base_type) list) Hashtbl.t;
  (* 语义标签 -> [(变量名, 基础类型)] *)
}

let infer_semantic_type context label expr_type = 
  (* 根据语义标签和表达式类型推断最终类型 *)
  ...

let check_semantic_combination context labels =
  (* 检查语义组合的有效性 *)
  ...
```

### 5. 代码生成扩展

#### 运行时表示
```ocaml
(* 在 codegen.ml 中添加语义类型运行时支持 *)
type runtime_value = 
  (* 现有类型... *)
  | SemanticValue of string * runtime_value (* 语义标签 + 实际值 *)
  | CombinedValue of (string * runtime_value) list (* 组合值 *)

let eval_semantic_let env var_name semantic_type value_expr =
  (* 执行语义类型赋值 *)
  ...

let eval_combine_expr env expr_list =
  (* 执行组合表达式 *)
  ...
```

## 实施计划

### 阶段1: 基础语义标注 (第1-2天)
1. ✅ 扩展词法分析器添加新关键字
2. ✅ 扩展AST添加语义类型节点
3. ✅ 实现基础语义标注解析
4. ✅ 添加基础语义类型检查
5. ✅ 编写基础测试

### 阶段2: 语义组合功能 (第3-4天)  
1. ✅ 实现组合表达式解析
2. ✅ 添加组合类型推断
3. ✅ 实现组合值运行时表示
4. ✅ 编写组合功能测试

### 阶段3: 高级特性 (第5-6天)
1. ✅ 实现条件守卫（when子句）
2. ✅ 添加语义类型模式匹配
3. ✅ 优化错误信息和提示
4. ✅ 完善测试覆盖

### 阶段4: 集成和优化 (第7天)
1. ✅ 与现有类型系统集成
2. ✅ 性能优化
3. ✅ 文档完善
4. ✅ 端到端测试

## 测试策略

### 单元测试
```chinese
# 测试语义类型标注
让 年龄 作为 用户信息 = 25
断言 (类型 年龄) == "用户信息:整数"

# 测试组合功能
让 姓名 作为 用户信息 = "张三"
让 用户 = 组合 年龄 和 姓名
断言 (字段数量 用户) == 2
```

### 集成测试
```chinese
# 测试完整的语义类型程序
让 学生年龄 作为 学生信息 = 20
让 学生姓名 作为 学生信息 = "李四"
让 学生成绩 作为 学生信息 = 95.5

让 学生记录 = 组合 学生年龄 和 学生姓名 和 学生成绩

函数 评估学生 (记录: 学生信息组合) ->
  匹配 记录 与
  | 组合 age 和 name 和 score 当 score >= 90 ->
    打印 name + " 是优秀学生"
  | 组合 age 和 name 和 score ->
    打印 name + " 需要努力"

评估学生 学生记录
```

## 错误处理

### 语义错误类型
1. **语义标签不匹配**: 不同语义标签的值不能直接组合
2. **组合类型错误**: 组合操作的参数必须有相同语义标签
3. **守卫条件错误**: when子句中的条件必须是布尔表达式

### 错误信息设计
```
错误: 语义类型不匹配
位置: 第5行第10列
说明: 无法将 "用户信息" 类型的值与 "产品信息" 类型的值组合
建议: 确保要组合的值具有相同的语义标签

错误: 未知语义标签
位置: 第3行第15列  
说明: 语义标签 "未定义信息" 未在此作用域中声明
建议: 检查语义标签的拼写，或先定义此类型的变量
```

## 向后兼容性

### 兼容策略
1. **语法兼容**: 新语法作为可选特性，不影响现有代码
2. **类型兼容**: 语义类型可与现有类型系统互操作
3. **渐进式采用**: 可以在同一程序中混用两种类型系统

### 迁移路径
```chinese
# 阶段1: 现有代码继续工作
让 x: 整数 = 10

# 阶段2: 混合使用
让 y 作为 数值信息 = 20
让 结果 = x + y  # 自动类型转换

# 阶段3: 完全语义化
让 所有数据 作为 数值信息 = [x, y, 30]
```

## 实施检查清单

### 词法分析器 ✅
- [ ] 添加 AS 词元 (`作为`)
- [ ] 添加 COMBINE 词元 (`组合`)  
- [ ] 添加 AND_OP 词元 (`和`)
- [ ] 添加 WHEN 词元 (`当`)
- [ ] 更新关键字识别

### 语法分析器 ✅ 
- [ ] 扩展 AST 节点定义
- [ ] 实现语义标注解析
- [ ] 实现组合表达式解析
- [ ] 实现条件守卫解析
- [ ] 更新错误处理

### 语义分析器 ✅
- [ ] 添加语义类型上下文
- [ ] 实现语义类型推断
- [ ] 实现组合类型检查
- [ ] 添加语义错误检测
- [ ] 与现有类型系统集成

### 代码生成器 ✅
- [ ] 添加语义值运行时表示
- [ ] 实现语义标注求值
- [ ] 实现组合表达式求值
- [ ] 实现条件守卫求值
- [ ] 优化运行时性能

### 测试 ✅
- [ ] 编写词法分析测试
- [ ] 编写语法分析测试
- [ ] 编写语义分析测试
- [ ] 编写代码生成测试
- [ ] 编写端到端测试

## 成功标准

### 功能标准
1. ✅ 支持基础语义类型标注语法
2. ✅ 支持语义类型组合操作
3. ✅ 支持条件守卫模式匹配
4. ✅ 与现有类型系统兼容
5. ✅ 提供清晰的错误信息

### 质量标准  
1. ✅ 100% 测试覆盖新功能
2. ✅ 性能影响 < 10%
3. ✅ 向后兼容现有代码
4. ✅ 详细文档和示例
5. ✅ AI友好的错误提示

### 用户体验标准
1. ✅ AI能轻松理解和使用新语法
2. ✅ 错误信息帮助快速定位问题
3. ✅ 渐进式学习曲线
4. ✅ 与现有工作流程集成
5. ✅ 提升编程效率和准确性

这个语义类型系统将是骆言编译器向AI友好编程语言转变的重要第一步！
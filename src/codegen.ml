(** 豫语代码生成器/解释器 - Chinese Programming Language Code Generator/Interpreter *)

open Ast

(** 运行时值 *)
type 运行时值 =
  | 整数值 of int
  | 浮点值 of float
  | 字符串值 of string
  | 布尔值 of bool
  | 单元值
  | 函数值 of string list * 表达式 * 运行时环境  (* 参数列表, 函数体, 闭包环境 *)
  | 内置函数值 of (运行时值 list -> 运行时值)

(** 运行时环境 *)
and 运行时环境 = (string * 运行时值) list

(** 运行时错误 *)
exception 运行时错误 of string

(** 创建空环境 *)
let 空环境 = []

(** 在环境中查找变量 *)
let rec 查找变量 环境 变量名 =
  match 环境 with
  | [] -> raise (运行时错误 ("未定义的变量: " ^ 变量名))
  | (名称, 值) :: 剩余环境 ->
    if 名称 = 变量名 then 值
    else 查找变量 剩余环境 变量名

(** 在环境中绑定变量 *)
let 绑定变量 环境 变量名 值 = (变量名, 值) :: 环境

(** 内置函数实现 *)
let 内置函数 = [
  ("打印", 内置函数值 (function
    | [字符串值 s] -> print_endline s; 单元值
    | [值] -> print_endline (值到字符串 值); 单元值
    | _ -> raise (运行时错误 "打印函数期望一个参数")));
    
  ("读取", 内置函数值 (function
    | [单元值] -> 字符串值 (read_line ())
    | [] -> 字符串值 (read_line ())
    | _ -> raise (运行时错误 "读取函数不需要参数")));
    
  ("长度", 内置函数值 (function
    | [字符串值 s] -> 整数值 (String.length s)
    | _ -> raise (运行时错误 "长度函数期望一个字符串参数")));
]

(** 值转换为字符串 *)
and 值到字符串 值 =
  match 值 with
  | 整数值 n -> string_of_int n
  | 浮点值 f -> string_of_float f
  | 字符串值 s -> s
  | 布尔值 b -> if b then "真" else "假"
  | 单元值 -> "()"
  | 函数值 (_, _, _) -> "<函数>"
  | 内置函数值 _ -> "<内置函数>"

(** 值转换为布尔值 *)
let 值到布尔 值 =
  match 值 with
  | 布尔值 b -> b
  | 整数值 0 -> false
  | 整数值 _ -> true
  | 字符串值 "" -> false
  | 字符串值 _ -> true
  | 单元值 -> false
  | _ -> true

(** 二元运算实现 *)
let 执行二元运算 运算符 左值 右值 =
  match (运算符, 左值, 右值) with
  (* 算术运算 *)
  | (加法, 整数值 a, 整数值 b) -> 整数值 (a + b)
  | (减法, 整数值 a, 整数值 b) -> 整数值 (a - b)
  | (乘法, 整数值 a, 整数值 b) -> 整数值 (a * b)
  | (除法, 整数值 a, 整数值 b) -> 
    if b = 0 then raise (运行时错误 "除零错误")
    else 整数值 (a / b)
  | (加法, 浮点值 a, 浮点值 b) -> 浮点值 (a +. b)
  | (减法, 浮点值 a, 浮点值 b) -> 浮点值 (a -. b)
  | (乘法, 浮点值 a, 浮点值 b) -> 浮点值 (a *. b)
  | (除法, 浮点值 a, 浮点值 b) -> 浮点值 (a /. b)
  
  (* 字符串连接 *)
  | (加法, 字符串值 a, 字符串值 b) -> 字符串值 (a ^ b)
  
  (* 比较运算 *)
  | (等于, a, b) -> 布尔值 (a = b)
  | (不等于, a, b) -> 布尔值 (a <> b)
  | (小于, 整数值 a, 整数值 b) -> 布尔值 (a < b)
  | (小于等于, 整数值 a, 整数值 b) -> 布尔值 (a <= b)
  | (大于, 整数值 a, 整数值 b) -> 布尔值 (a > b)
  | (大于等于, 整数值 a, 整数值 b) -> 布尔值 (a >= b)
  | (小于, 浮点值 a, 浮点值 b) -> 布尔值 (a < b)
  | (小于等于, 浮点值 a, 浮点值 b) -> 布尔值 (a <= b)
  | (大于, 浮点值 a, 浮点值 b) -> 布尔值 (a > b)
  | (大于等于, 浮点值 a, 浮点值 b) -> 布尔值 (a >= b)
  
  (* 逻辑运算 *)
  | (逻辑与, a, b) -> 布尔值 (值到布尔 a && 值到布尔 b)
  | (逻辑或, a, b) -> 布尔值 (值到布尔 a || 值到布尔 b)
  
  | _ -> raise (运行时错误 ("不支持的二元运算: " ^ 值到字符串 左值 ^ " " ^ 值到字符串 右值))

(** 一元运算实现 *)
let 执行一元运算 运算符 值 =
  match (运算符, 值) with
  | (负号, 整数值 n) -> 整数值 (-n)
  | (负号, 浮点值 f) -> 浮点值 (-.f)
  | (逻辑非, v) -> 布尔值 (not (值到布尔 v))
  | _ -> raise (运行时错误 ("不支持的一元运算: " ^ 值到字符串 值))

(** 模式匹配 *)
let rec 匹配模式 模式 值 环境 =
  match (模式, 值) with
  | (通配符模式, _) -> Some 环境
  | (变量模式 变量名, 值) -> Some (绑定变量 环境 变量名 值)
  | (字面量模式 (整数字面量 n1), 整数值 n2) when n1 = n2 -> Some 环境
  | (字面量模式 (浮点字面量 f1), 浮点值 f2) when f1 = f2 -> Some 环境
  | (字面量模式 (字符串字面量 s1), 字符串值 s2) when s1 = s2 -> Some 环境
  | (字面量模式 (布尔字面量 b1), 布尔值 b2) when b1 = b2 -> Some 环境
  | (字面量模式 单元字面量, 单元值) -> Some 环境
  | _ -> None

(** 求值表达式 *)
let rec 求值表达式 环境 表达式 =
  match 表达式 with
  | 字面量表达式 字面量 -> 求值字面量 字面量
  
  | 变量表达式 变量名 -> 查找变量 环境 变量名
  
  | 二元运算表达式 (左表达式, 运算符, 右表达式) ->
    let 左值 = 求值表达式 环境 左表达式 in
    let 右值 = 求值表达式 环境 右表达式 in
    执行二元运算 运算符 左值 右值
    
  | 一元运算表达式 (运算符, 表达式) ->
    let 值 = 求值表达式 环境 表达式 in
    执行一元运算 运算符 值
    
  | 函数调用表达式 (函数表达式, 参数列表) ->
    let 函数值 = 求值表达式 环境 函数表达式 in
    let 参数值列表 = List.map (求值表达式 环境) 参数列表 in
    调用函数 函数值 参数值列表
    
  | 条件表达式 (条件, 那么分支, 否则分支) ->
    let 条件值 = 求值表达式 环境 条件 in
    if 值到布尔 条件值 then
      求值表达式 环境 那么分支
    else
      求值表达式 环境 否则分支
      
  | 函数表达式 (参数列表, 主体) ->
    函数值 (参数列表, 主体, 环境)
    
  | 让表达式 (变量名, 值表达式, 主体表达式) ->
    let 值 = 求值表达式 环境 值表达式 in
    let 新环境 = 绑定变量 环境 变量名 值 in
    求值表达式 新环境 主体表达式
    
  | 匹配表达式 (表达式, 分支列表) ->
    let 值 = 求值表达式 环境 表达式 in
    执行匹配 环境 值 分支列表
    
  | _ -> raise (运行时错误 "不支持的表达式类型")

(** 求值字面量 *)
and 求值字面量 字面量 =
  match 字面量 with
  | 整数字面量 n -> 整数值 n
  | 浮点字面量 f -> 浮点值 f
  | 字符串字面量 s -> 字符串值 s
  | 布尔字面量 b -> 布尔值 b
  | 单元字面量 -> 单元值

(** 调用函数 *)
and 调用函数 函数值 参数值列表 =
  match 函数值 with
  | 内置函数值 f -> f 参数值列表
  | 函数值 (参数列表, 主体, 闭包环境) ->
    if List.length 参数列表 <> List.length 参数值列表 then
      raise (运行时错误 "函数参数数量不匹配")
    else
      let 新环境 = List.fold_left2 (fun 累积环境 参数名 参数值 ->
        绑定变量 累积环境 参数名 参数值
      ) 闭包环境 参数列表 参数值列表 in
      求值表达式 新环境 主体
  | _ -> raise (运行时错误 "尝试调用非函数值")

(** 执行模式匹配 *)
and 执行匹配 环境 值 分支列表 =
  match 分支列表 with
  | [] -> raise (运行时错误 "模式匹配失败：没有匹配的分支")
  | (模式, 表达式) :: 剩余分支 ->
    (match 匹配模式 模式 值 环境 with
     | Some 新环境 -> 求值表达式 新环境 表达式
     | None -> 执行匹配 环境 值 剩余分支)

(** 执行语句 *)
let 执行语句 环境 语句 =
  match 语句 with
  | 表达式语句 表达式 ->
    let 值 = 求值表达式 环境 表达式 in
    (环境, 值)
    
  | 让语句 (变量名, 表达式) ->
    let 值 = 求值表达式 环境 表达式 in
    let 新环境 = 绑定变量 环境 变量名 值 in
    (新环境, 值)
    
  | 递归让语句 (函数名, 表达式) ->
    (* 创建递归函数 *)
    let rec 创建递归函数 () =
      match 表达式 with
      | 函数表达式 (参数列表, 主体) ->
        let 递归环境 = 绑定变量 环境 函数名 (创建递归函数 ()) in
        函数值 (参数列表, 主体, 递归环境)
      | _ -> raise (运行时错误 "递归让语句期望函数表达式")
    in
    let 函数值 = 创建递归函数 () in
    let 新环境 = 绑定变量 环境 函数名 函数值 in
    (新环境, 函数值)
    
  | 类型定义语句 (类型名, 类型定义) ->
    (* 简化版：类型定义不产生运行时值 *)
    (环境, 单元值)

(** 执行程序 *)
let 执行程序 程序 =
  let 初始环境 = 内置函数 @ 空环境 in
  
  let rec 执行语句列表 环境 语句列表 最后值 =
    match 语句列表 with
    | [] -> 最后值
    | 语句 :: 剩余语句 ->
      let (新环境, 值) = 执行语句 环境 语句 in
      执行语句列表 新环境 剩余语句 值
  in
  
  try
    let 结果 = 执行语句列表 初始环境 程序 单元值 in
    Ok 结果
  with
  | 运行时错误 消息 -> Error ("运行时错误: " ^ 消息)
  | e -> Error ("未知错误: " ^ Printexc.to_string e)

(** 解释执行入口函数 *)
let 解释执行 程序 =
  match 执行程序 程序 with
  | Ok 结果 -> 
    Printf.printf "程序执行完成，结果: %s\n" (值到字符串 结果);
    true
  | Error 错误消息 ->
    Printf.printf "执行错误: %s\n" 错误消息;
    false

(** 交互式求值 *)
let 交互式求值 表达式 环境 =
  try
    let 结果 = 求值表达式 环境 表达式 in
    Printf.printf "=> %s\n" (值到字符串 结果);
    环境
  with
  | 运行时错误 消息 ->
    Printf.printf "错误: %s\n" 消息;
    环境
  | e ->
    Printf.printf "未知错误: %s\n" (Printexc.to_string e);
    环境
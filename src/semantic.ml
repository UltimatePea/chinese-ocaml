(** 豫语语义分析器 - Chinese Programming Language Semantic Analyzer *)

open Ast
open Types

(** 语义错误 *)
exception 语义错误 of string

(** 符号表条目 *)
type 符号表条目 = {
  符号名: string;
  符号类型: 类型;
  是否可变: bool;
  定义位置: int;  (* 简化版位置信息 *)
}

(** 符号表 *)
module 符号表 = Map.Make(String)
type 符号表_t = 符号表条目 符号表.t

(** 作用域栈 *)
type 作用域栈 = 符号表_t list

(** 语义分析上下文 *)
type 语义上下文 = {
  作用域栈: 作用域栈;
  当前函数返回类型: 类型 option;
  错误列表: string list;
}

(** 创建初始上下文 *)
let 创建初始上下文 () = {
  作用域栈 = [符号表.empty];
  当前函数返回类型 = None;
  错误列表 = [];
}

(** 添加内置函数到上下文 *)
let 添加内置函数 上下文 =
  let 内置符号表 = 符号表.empty in
  let 内置符号表 = 符号表.add "打印" {
    符号名 = "打印";
    符号类型 = 函数类型_T (字符串类型_T, 单元类型_T);
    是否可变 = false;
    定义位置 = 0;
  } 内置符号表 in
  let 内置符号表 = 符号表.add "读取" {
    符号名 = "读取";
    符号类型 = 函数类型_T (单元类型_T, 字符串类型_T);
    是否可变 = false;
    定义位置 = 0;
  } 内置符号表 in
  { 上下文 with 作用域栈 = 内置符号表 :: 上下文.作用域栈 }

(** 进入新作用域 *)
let 进入作用域 上下文 =
  { 上下文 with 作用域栈 = 符号表.empty :: 上下文.作用域栈 }

(** 退出作用域 *)
let 退出作用域 上下文 =
  match 上下文.作用域栈 with
  | [] -> raise (语义错误 "尝试退出空作用域栈")
  | _ :: 剩余作用域 -> { 上下文 with 作用域栈 = 剩余作用域 }

(** 在当前作用域中添加符号 *)
let 添加符号 上下文 符号名 符号类型 是否可变 =
  match 上下文.作用域栈 with
  | [] -> raise (语义错误 "空作用域栈")
  | 当前作用域 :: 剩余作用域 ->
    if 符号表.mem 符号名 当前作用域 then
      { 上下文 with 错误列表 = ("符号重复定义: " ^ 符号名) :: 上下文.错误列表 }
    else
      let 新条目 = {
        符号名;
        符号类型;
        是否可变;
        定义位置 = 0;  (* 简化版 *)
      } in
      let 新当前作用域 = 符号表.add 符号名 新条目 当前作用域 in
      { 上下文 with 作用域栈 = 新当前作用域 :: 剩余作用域 }

(** 查找符号 *)
let rec 查找符号 作用域栈 符号名 =
  match 作用域栈 with
  | [] -> None
  | 当前作用域 :: 剩余作用域 ->
    try Some (符号表.find 符号名 当前作用域)
    with Not_found -> 查找符号 剩余作用域 符号名

(** 将类型环境转换为符号表 *)
let 环境到符号表 环境 =
  类型环境.fold (fun 符号名 类型 符号表 ->
    let 条目 = {
      符号名;
      符号类型 = 类型;
      是否可变 = false;
      定义位置 = 0;
    } in
    符号表.add 符号名 条目 符号表
  ) 环境 符号表.empty

(** 将符号表转换为类型环境 *)
let 符号表到环境 符号表 =
  符号表.fold (fun 符号名 条目 环境 ->
    类型环境.add 符号名 条目.符号类型 环境
  ) 符号表 类型环境.empty

(** 分析表达式 *)
let rec 分析表达式 上下文 表达式 =
  let 环境 = match 上下文.作用域栈 with
    | [] -> 类型环境.empty
    | 作用域列表 ->
      List.fold_left (fun 累积环境 作用域 ->
        let 当前环境 = 符号表到环境 作用域 in
        类型环境.fold 类型环境.add 当前环境 累积环境
      ) 类型环境.empty 作用域列表
  in
  
  try
    let (_, 推断类型) = 推断类型 环境 表达式 in
    
    (* 额外的语义检查 *)
    let 上下文1 = 检查表达式语义 上下文 表达式 in
    (上下文1, Some 推断类型)
  with
  | 类型错误 消息 ->
    let 错误消息 = "类型错误: " ^ 消息 in
    ({ 上下文 with 错误列表 = 错误消息 :: 上下文.错误列表 }, None)
  | 语义错误 消息 ->
    ({ 上下文 with 错误列表 = 消息 :: 上下文.错误列表 }, None)

(** 检查表达式语义 *)
and 检查表达式语义 上下文 表达式 =
  match 表达式 with
  | 变量表达式 变量名 ->
    (match 查找符号 上下文.作用域栈 变量名 with
     | Some _ -> 上下文
     | None -> { 上下文 with 错误列表 = ("未定义的变量: " ^ 变量名) :: 上下文.错误列表 })
     
  | 二元运算表达式 (左表达式, 运算符, 右表达式) ->
    let 上下文1 = 检查表达式语义 上下文 左表达式 in
    检查表达式语义 上下文1 右表达式
    
  | 一元运算表达式 (运算符, 表达式) ->
    检查表达式语义 上下文 表达式
    
  | 函数调用表达式 (函数表达式, 参数列表) ->
    let 上下文1 = 检查表达式语义 上下文 函数表达式 in
    List.fold_left 检查表达式语义 上下文1 参数列表
    
  | 条件表达式 (条件, 那么分支, 否则分支) ->
    let 上下文1 = 检查表达式语义 上下文 条件 in
    let 上下文2 = 检查表达式语义 上下文1 那么分支 in
    检查表达式语义 上下文2 否则分支
    
  | 函数表达式 (参数列表, 主体) ->
    let 上下文1 = 进入作用域 上下文 in
    let 上下文2 = List.fold_left (fun 累积上下文 参数名 ->
      添加符号 累积上下文 参数名 (新类型变量 ()) false
    ) 上下文1 参数列表 in
    let 上下文3 = 检查表达式语义 上下文2 主体 in
    退出作用域 上下文3
    
  | 让表达式 (变量名, 值表达式, 主体表达式) ->
    let 上下文1 = 检查表达式语义 上下文 值表达式 in
    let 上下文2 = 进入作用域 上下文1 in
    let 上下文3 = 添加符号 上下文2 变量名 (新类型变量 ()) false in
    let 上下文4 = 检查表达式语义 上下文3 主体表达式 in
    退出作用域 上下文4
    
  | 匹配表达式 (表达式, 分支列表) ->
    let 上下文1 = 检查表达式语义 上下文 表达式 in
    List.fold_left (fun 累积上下文 (模式, 分支表达式) ->
      let 上下文2 = 进入作用域 累积上下文 in
      let 上下文3 = 检查模式语义 上下文2 模式 in
      let 上下文4 = 检查表达式语义 上下文3 分支表达式 in
      退出作用域 上下文4
    ) 上下文1 分支列表
    
  | _ -> 上下文

(** 检查模式语义 *)
and 检查模式语义 上下文 模式 =
  match 模式 with
  | 变量模式 变量名 ->
    添加符号 上下文 变量名 (新类型变量 ()) false
  | 构造器模式 (构造器名, 子模式列表) ->
    List.fold_left 检查模式语义 上下文 子模式列表
  | 元组模式 模式列表 ->
    List.fold_left 检查模式语义 上下文 模式列表
  | 列表模式 模式列表 ->
    List.fold_left 检查模式语义 上下文 模式列表
  | 或模式 (模式1, 模式2) ->
    let 上下文1 = 检查模式语义 上下文 模式1 in
    检查模式语义 上下文1 模式2
  | _ -> 上下文

(** 分析语句 *)
let 分析语句 上下文 语句 =
  match 语句 with
  | 表达式语句 表达式 ->
    分析表达式 上下文 表达式
    
  | 让语句 (变量名, 表达式) ->
    let (上下文1, 表达式类型) = 分析表达式 上下文 表达式 in
    (match 表达式类型 with
     | Some 类型 -> (添加符号 上下文1 变量名 类型 false, Some 类型)
     | None -> (上下文1, None))
     
  | 递归让语句 (函数名, 表达式) ->
    (* 递归函数需要先在环境中声明自己 *)
    let 函数类型 = 新类型变量 () in
    let 上下文1 = 添加符号 上下文 函数名 函数类型 false in
    let (上下文2, 推断类型) = 分析表达式 上下文1 表达式 in
    
    (* 检查推断出的类型是否与预期一致 *)
    (match 推断类型 with
     | Some 类型 ->
       try
         let _ = 合一 函数类型 类型 in
         (上下文2, Some 类型)
       with 类型错误 消息 ->
         let 错误消息 = "递归函数类型不一致: " ^ 消息 in
         ({ 上下文2 with 错误列表 = 错误消息 :: 上下文2.错误列表 }, None)
     | None -> (上下文2, None))
     
  | 类型定义语句 (类型名, 类型定义) ->
    (* 简化版类型定义处理 *)
    (上下文, Some 单元类型_T)

(** 分析程序 *)
let 分析程序 程序 =
  let 初始上下文 = 添加内置函数 (创建初始上下文 ()) in
  
  let rec 分析语句列表 上下文 语句列表 =
    match 语句列表 with
    | [] -> 上下文
    | 语句 :: 剩余语句 ->
      let (新上下文, _) = 分析语句 上下文 语句 in
      分析语句列表 新上下文 剩余语句
  in
  
  let 最终上下文 = 分析语句列表 初始上下文 程序 in
  
  (* 返回分析结果 *)
  if 最终上下文.错误列表 = [] then
    Ok "语义分析成功"
  else
    Error (List.rev 最终上下文.错误列表)

(** 类型检查入口函数 *)
let 类型检查 程序 =
  match 分析程序 程序 with
  | Ok 消息 -> Printf.printf "%s\n" 消息; true
  | Error 错误列表 ->
    Printf.printf "语义分析错误:\n";
    List.iter (Printf.printf "  - %s\n") 错误列表;
    false

(** 获取表达式类型 *)
let 获取表达式类型 上下文 表达式 =
  let (_, 类型选项) = 分析表达式 上下文 表达式 in
  类型选项
(** 豫语语法分析器 - Chinese Programming Language Parser *)

open Ast
open Lexer

(** 语法错误 *)
exception 语法错误 of string * 位置

(** 解析器状态 *)
type 解析状态 = {
  词元列表: 带位置词元 list;
  当前位置: int;
}

(** 创建解析状态 *)
let 创建解析状态 词元列表 = {
  词元列表;
  当前位置 = 0;
}

(** 获取当前词元 *)
let 当前词元 状态 =
  if 状态.当前位置 >= List.length 状态.词元列表 then
    (文件结束, { 行号 = 0; 列号 = 0; 文件名 = "" })
  else
    List.nth 状态.词元列表 状态.当前位置

(** 向前移动 *)
let 前进解析 状态 =
  if 状态.当前位置 >= List.length 状态.词元列表 then 状态
  else { 状态 with 当前位置 = 状态.当前位置 + 1 }

(** 期望特定词元 *)
let 期望词元 状态 期望的词元 =
  let (词元, 位置) = 当前词元 状态 in
  if 词元 = 期望的词元 then
    前进解析 状态
  else
    raise (语法错误 ("期望 " ^ show_词元 期望的词元 ^ "，但遇到 " ^ show_词元 词元, 位置))

(** 检查是否为特定词元 *)
let 是词元 状态 目标词元 =
  let (词元, _) = 当前词元 状态 in
  词元 = 目标词元

(** 解析标识符 *)
let 解析标识符 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 标识符词元 name -> (name, 前进解析 状态)
  | _ -> raise (语法错误 ("期望标识符，但遇到 " ^ show_词元 词元, 位置))

(** 解析字面量 *)
let 解析字面量 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 整数词元 n -> (整数字面量 n, 前进解析 状态)
  | 浮点词元 f -> (浮点字面量 f, 前进解析 状态)
  | 字符串词元 s -> (字符串字面量 s, 前进解析 状态)
  | 布尔词元 b -> (布尔字面量 b, 前进解析 状态)
  | _ -> raise (语法错误 ("期望字面量，但遇到 " ^ show_词元 词元, 位置))

(** 解析二元运算符 *)
let 词元到二元运算符 词元 =
  match 词元 with
  | 加号 -> Some 加法
  | 减号 -> Some 减法
  | 乘号 -> Some 乘法
  | 除号 -> Some 除法
  | 等于号 -> Some 等于
  | 不等于号 -> Some 不等于
  | 小于号 -> Some 小于
  | 小于等于号 -> Some 小于等于
  | 大于号 -> Some 大于
  | 大于等于号 -> Some 大于等于
  | 并且关键字 -> Some 逻辑与
  | 或者关键字 -> Some 逻辑或
  | _ -> None

(** 运算符优先级 *)
let 运算符优先级 运算符 =
  match 运算符 with
  | 逻辑或 -> 1
  | 逻辑与 -> 2
  | 等于 | 不等于 | 小于 | 小于等于 | 大于 | 大于等于 -> 3
  | 加法 | 减法 -> 4
  | 乘法 | 除法 -> 5

(** 前向声明 *)
let rec 解析表达式 状态 = 解析逻辑或表达式 状态

(** 解析逻辑或表达式 *)
and 解析逻辑或表达式 状态 =
  let rec 解析_尾递归 左表达式 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元到二元运算符 词元 with
    | Some 逻辑或 ->
      let 状态1 = 前进解析 状态 in
      let (右表达式, 状态2) = 解析逻辑与表达式 状态1 in
      let 新表达式 = 二元运算表达式 (左表达式, 逻辑或, 右表达式) in
      解析_尾递归 新表达式 状态2
    | _ -> (左表达式, 状态)
  in
  let (表达式, 状态1) = 解析逻辑与表达式 状态 in
  解析_尾递归 表达式 状态1

(** 解析逻辑与表达式 *)
and 解析逻辑与表达式 状态 =
  let rec 解析_尾递归 左表达式 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元到二元运算符 词元 with
    | Some 逻辑与 ->
      let 状态1 = 前进解析 状态 in
      let (右表达式, 状态2) = 解析比较表达式 状态1 in
      let 新表达式 = 二元运算表达式 (左表达式, 逻辑与, 右表达式) in
      解析_尾递归 新表达式 状态2
    | _ -> (左表达式, 状态)
  in
  let (表达式, 状态1) = 解析比较表达式 状态 in
  解析_尾递归 表达式 状态1

(** 解析比较表达式 *)
and 解析比较表达式 状态 =
  let rec 解析_尾递归 左表达式 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元到二元运算符 词元 with
    | Some (等于 | 不等于 | 小于 | 小于等于 | 大于 | 大于等于 as 运算符) ->
      let 状态1 = 前进解析 状态 in
      let (右表达式, 状态2) = 解析算术表达式 状态1 in
      let 新表达式 = 二元运算表达式 (左表达式, 运算符, 右表达式) in
      解析_尾递归 新表达式 状态2
    | _ -> (左表达式, 状态)
  in
  let (表达式, 状态1) = 解析算术表达式 状态 in
  解析_尾递归 表达式 状态1

(** 解析算术表达式 *)
and 解析算术表达式 状态 =
  let rec 解析_尾递归 左表达式 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元到二元运算符 词元 with
    | Some (加法 | 减法 as 运算符) ->
      let 状态1 = 前进解析 状态 in
      let (右表达式, 状态2) = 解析乘除表达式 状态1 in
      let 新表达式 = 二元运算表达式 (左表达式, 运算符, 右表达式) in
      解析_尾递归 新表达式 状态2
    | _ -> (左表达式, 状态)
  in
  let (表达式, 状态1) = 解析乘除表达式 状态 in
  解析_尾递归 表达式 状态1

(** 解析乘除表达式 *)
and 解析乘除表达式 状态 =
  let rec 解析_尾递归 左表达式 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元到二元运算符 词元 with
    | Some (乘法 | 除法 as 运算符) ->
      let 状态1 = 前进解析 状态 in
      let (右表达式, 状态2) = 解析一元表达式 状态1 in
      let 新表达式 = 二元运算表达式 (左表达式, 运算符, 右表达式) in
      解析_尾递归 新表达式 状态2
    | _ -> (左表达式, 状态)
  in
  let (表达式, 状态1) = 解析一元表达式 状态 in
  解析_尾递归 表达式 状态1

(** 解析一元表达式 *)
and 解析一元表达式 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 减号 ->
    let 状态1 = 前进解析 状态 in
    let (表达式, 状态2) = 解析一元表达式 状态1 in
    (一元运算表达式 (负号, 表达式), 状态2)
  | 非关键字 ->
    let 状态1 = 前进解析 状态 in
    let (表达式, 状态2) = 解析一元表达式 状态1 in
    (一元运算表达式 (逻辑非, 表达式), 状态2)
  | _ -> 解析基础表达式 状态

(** 解析基础表达式 *)
and 解析基础表达式 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 整数词元 _ | 浮点词元 _ | 字符串词元 _ | 布尔词元 _ ->
    let (字面量, 状态1) = 解析字面量 状态 in
    (字面量表达式 字面量, 状态1)
  | 标识符词元 name ->
    let 状态1 = 前进解析 状态 in
    解析函数调用或变量 name 状态1
  | 左圆括号 ->
    let 状态1 = 前进解析 状态 in
    let (表达式, 状态2) = 解析表达式 状态1 in
    let 状态3 = 期望词元 状态2 右圆括号 in
    (表达式, 状态3)
  | 如果关键字 -> 解析条件表达式 状态
  | 匹配关键字 -> 解析匹配表达式 状态
  | 函数关键字 -> 解析函数表达式 状态
  | 让关键字 -> 解析让表达式 状态
  | _ -> raise (语法错误 ("意外的词元: " ^ show_词元 词元, 位置))

(** 解析函数调用或变量 *)
and 解析函数调用或变量 name 状态 =
  let rec 收集参数 参数列表 状态 =
    match 当前词元 状态 with
    | (左圆括号 | 标识符词元 _ | 整数词元 _ | 浮点词元 _ | 字符串词元 _ | 布尔词元 _, _) ->
      let (参数, 状态1) = 解析基础表达式 状态 in
      收集参数 (参数 :: 参数列表) 状态1
    | _ -> (List.rev 参数列表, 状态)
  in
  let (参数列表, 状态1) = 收集参数 [] 状态 in
  if 参数列表 = [] then
    (变量表达式 name, 状态1)
  else
    (函数调用表达式 (变量表达式 name, 参数列表), 状态1)

(** 解析条件表达式 *)
and 解析条件表达式 状态 =
  let 状态1 = 期望词元 状态 如果关键字 in
  let (条件, 状态2) = 解析表达式 状态1 in
  let 状态3 = 期望词元 状态2 那么关键字 in
  let (那么分支, 状态4) = 解析表达式 状态3 in
  let 状态5 = 期望词元 状态4 否则关键字 in
  let (否则分支, 状态6) = 解析表达式 状态5 in
  (条件表达式 (条件, 那么分支, 否则分支), 状态6)

(** 解析匹配表达式 *)
and 解析匹配表达式 状态 =
  let 状态1 = 期望词元 状态 匹配关键字 in
  let (表达式, 状态2) = 解析表达式 状态1 in
  let 状态3 = 期望词元 状态2 与关键字 in
  let rec 解析分支列表 分支列表 状态 =
    if 是词元 状态 竖线 then
      let 状态1 = 前进解析 状态 in
      let (模式, 状态2) = 解析模式 状态1 in
      let 状态3 = 期望词元 状态2 箭头 in
      let (表达式, 状态4) = 解析表达式 状态3 in
      解析分支列表 ((模式, 表达式) :: 分支列表) 状态4
    else
      (List.rev 分支列表, 状态)
  in
  let (分支列表, 状态4) = 解析分支列表 [] 状态3 in
  (匹配表达式 (表达式, 分支列表), 状态4)

(** 解析模式 *)
and 解析模式 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 下划线 -> (通配符模式, 前进解析 状态)
  | 标识符词元 name -> (变量模式 name, 前进解析 状态)
  | 整数词元 n -> (字面量模式 (整数字面量 n), 前进解析 状态)
  | 浮点词元 f -> (字面量模式 (浮点字面量 f), 前进解析 状态)
  | 字符串词元 s -> (字面量模式 (字符串字面量 s), 前进解析 状态)
  | 布尔词元 b -> (字面量模式 (布尔字面量 b), 前进解析 状态)
  | _ -> raise (语法错误 ("意外的模式: " ^ show_词元 词元, 位置))

(** 解析函数表达式 *)
and 解析函数表达式 状态 =
  let 状态1 = 期望词元 状态 函数关键字 in
  let rec 解析参数列表 参数列表 状态 =
    let (词元, _) = 当前词元 状态 in
    match 词元 with
    | 标识符词元 name ->
      let 状态1 = 前进解析 状态 in
      解析参数列表 (name :: 参数列表) 状态1
    | 箭头 ->
      let 状态1 = 前进解析 状态 in
      (List.rev 参数列表, 状态1)
    | _ -> raise (语法错误 ("期望参数或箭头", snd (当前词元 状态)))
  in
  let (参数列表, 状态2) = 解析参数列表 [] 状态1 in
  let (表达式, 状态3) = 解析表达式 状态2 in
  (函数表达式 (参数列表, 表达式), 状态3)

(** 解析让表达式 *)
and 解析让表达式 状态 =
  let 状态1 = 期望词元 状态 让关键字 in
  let (名称, 状态2) = 解析标识符 状态1 in
  let 状态3 = 期望词元 状态2 等号 in
  let (值表达式, 状态4) = 解析表达式 状态3 in
  let 状态5 = 期望词元 状态4 在关键字 in
  let (主体表达式, 状态6) = 解析表达式 状态5 in
  (让表达式 (名称, 值表达式, 主体表达式), 状态6)

(** 解析语句 *)
let 解析语句 状态 =
  let (词元, 位置) = 当前词元 状态 in
  match 词元 with
  | 让关键字 ->
    let 状态1 = 前进解析 状态 in
    let (名称, 状态2) = 解析标识符 状态1 in
    let 状态3 = 期望词元 状态2 等号 in
    let (表达式, 状态4) = 解析表达式 状态3 in
    (让语句 (名称, 表达式), 状态4)
  | 递归关键字 ->
    let 状态1 = 前进解析 状态 in
    let 状态2 = 期望词元 状态1 让关键字 in
    let (名称, 状态3) = 解析标识符 状态2 in
    let 状态4 = 期望词元 状态3 等号 in
    let (表达式, 状态5) = 解析表达式 状态4 in
    (递归让语句 (名称, 表达式), 状态5)
  | _ ->
    let (表达式, 状态1) = 解析表达式 状态 in
    (表达式语句 表达式, 状态1)

(** 解析程序 *)
let 解析程序 词元列表 =
  let rec 解析语句列表 语句列表 状态 =
    let (词元, _) = 当前词元 状态 in
    if 词元 = 文件结束 then
      List.rev 语句列表
    else
      let (语句, 状态1) = 解析语句 状态 in
      解析语句列表 (语句 :: 语句列表) 状态1
  in
  let 初始状态 = 创建解析状态 词元列表 in
  解析语句列表 [] 初始状态
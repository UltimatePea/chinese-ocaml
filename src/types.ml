(** 豫语类型系统 - Chinese Programming Language Type System *)

open Ast

(** 类型 *)
type 类型 =
  | 整数类型_T
  | 浮点类型_T  
  | 字符串类型_T
  | 布尔类型_T
  | 单元类型_T
  | 函数类型_T of 类型 * 类型
  | 元组类型_T of 类型 list
  | 列表类型_T of 类型
  | 类型变量_T of string
  | 构造类型_T of string * 类型 list
[@@deriving show, eq]

(** 类型环境 *)
module 类型环境 = Map.Make(String)
type 环境 = 类型 类型环境.t

(** 类型错误 *)
exception 类型错误 of string

(** 类型变量计数器 *)
let 类型变量计数器 = ref 0

(** 生成新的类型变量 *)
let 新类型变量 () =
  incr 类型变量计数器;
  类型变量_T ("'a" ^ string_of_int !类型变量计数器)

(** 类型替换 *)
module 替换表 = Map.Make(String)
type 类型替换 = 类型 替换表.t

(** 空替换 *)
let 空替换 = 替换表.empty

(** 单一替换 *)
let 单一替换 变量名 类型 = 替换表.singleton 变量名 类型

(** 应用替换到类型 *)
let rec 应用替换 替换 类型 =
  match 类型 with
  | 类型变量_T name ->
    (try 替换表.find name 替换
     with Not_found -> 类型)
  | 函数类型_T (参数类型, 返回类型) ->
    函数类型_T (应用替换 替换 参数类型, 应用替换 替换 返回类型)
  | 元组类型_T 类型列表 ->
    元组类型_T (List.map (应用替换 替换) 类型列表)
  | 列表类型_T 元素类型 ->
    列表类型_T (应用替换 替换 元素类型)
  | 构造类型_T (名称, 类型列表) ->
    构造类型_T (名称, List.map (应用替换 替换) 类型列表)
  | _ -> 类型

(** 应用替换到环境 *)
let 应用替换到环境 替换 环境 =
  类型环境.map (应用替换 替换) 环境

(** 合成替换 *)
let 合成替换 替换1 替换2 =
  let 应用后替换1 = 替换表.map (应用替换 替换2) 替换1 in
  替换表.fold 替换表.add 替换2 应用后替换1

(** 获取类型中的自由变量 *)
let rec 自由变量 类型 =
  match 类型 with
  | 类型变量_T name -> [name]
  | 函数类型_T (参数类型, 返回类型) ->
    自由变量 参数类型 @ 自由变量 返回类型
  | 元组类型_T 类型列表 ->
    List.flatten (List.map 自由变量 类型列表)
  | 列表类型_T 元素类型 ->
    自由变量 元素类型
  | 构造类型_T (_, 类型列表) ->
    List.flatten (List.map 自由变量 类型列表)
  | _ -> []

(** 获取环境中的自由变量 *)
let 环境自由变量 环境 =
  类型环境.fold (fun _ 类型 累积 -> 自由变量 类型 @ 累积) 环境 []

(** 类型泛化 *)
let 泛化 环境 类型 =
  let 环境变量 = 环境自由变量 环境 in
  let 类型变量 = 自由变量 类型 in
  let 自由类型变量 = List.filter (fun v -> not (List.mem v 环境变量)) 类型变量 in
  (自由类型变量, 类型)

(** 类型实例化 *)
let 实例化 (量化变量列表, 类型) =
  let 替换 = List.fold_left (fun 累积 变量 ->
    替换表.add 变量 (新类型变量 ()) 累积
  ) 空替换 量化变量列表 in
  应用替换 替换 类型

(** 类型合一 *)
let rec 合一 类型1 类型2 =
  match (类型1, 类型2) with
  | (t1, t2) when t1 = t2 -> 空替换
  | (类型变量_T name, t) -> 变量合一 name t
  | (t, 类型变量_T name) -> 变量合一 name t
  | (函数类型_T (参数1, 返回1), 函数类型_T (参数2, 返回2)) ->
    let 替换1 = 合一 参数1 参数2 in
    let 替换2 = 合一 (应用替换 替换1 返回1) (应用替换 替换1 返回2) in
    合成替换 替换1 替换2
  | (元组类型_T 类型列表1, 元组类型_T 类型列表2) ->
    合一列表 类型列表1 类型列表2
  | (列表类型_T 元素1, 列表类型_T 元素2) ->
    合一 元素1 元素2
  | (构造类型_T (名称1, 类型列表1), 构造类型_T (名称2, 类型列表2)) when 名称1 = 名称2 ->
    合一列表 类型列表1 类型列表2
  | _ -> raise (类型错误 ("无法合一类型: " ^ show_类型 类型1 ^ " 与 " ^ show_类型 类型2))

(** 变量合一 *)
and 变量合一 变量名 类型 =
  if 类型 = 类型变量_T 变量名 then
    空替换
  else if List.mem 变量名 (自由变量 类型) then
    raise (类型错误 ("出现检查失败: " ^ 变量名 ^ " 出现在 " ^ show_类型 类型 ^ " 中"))
  else
    单一替换 变量名 类型

(** 合一类型列表 *)
and 合一列表 类型列表1 类型列表2 =
  match (类型列表1, 类型列表2) with
  | ([], []) -> 空替换
  | (t1 :: ts1, t2 :: ts2) ->
    let 替换1 = 合一 t1 t2 in
    let 替换2 = 合一列表 (List.map (应用替换 替换1) ts1) (List.map (应用替换 替换1) ts2) in
    合成替换 替换1 替换2
  | _ -> raise (类型错误 "类型列表长度不匹配")

(** 从基础类型转换 *)
let 从基础类型 基础类型 =
  match 基础类型 with
  | 整数类型 -> 整数类型_T
  | 浮点类型 -> 浮点类型_T
  | 字符串类型 -> 字符串类型_T
  | 布尔类型 -> 布尔类型_T
  | 单元类型 -> 单元类型_T

(** 从字面量推断类型 *)
let 字面量类型 字面量 =
  match 字面量 with
  | 整数字面量 _ -> 整数类型_T
  | 浮点字面量 _ -> 浮点类型_T
  | 字符串字面量 _ -> 字符串类型_T
  | 布尔字面量 _ -> 布尔类型_T
  | 单元字面量 -> 单元类型_T

(** 从二元运算符推断类型 *)
let 二元运算符类型 运算符 =
  match 运算符 with
  | 加法 | 减法 | 乘法 | 除法 ->
    (整数类型_T, 整数类型_T, 整数类型_T)  (* (左操作数, 右操作数, 结果) *)
  | 等于 | 不等于 ->
    let 变量 = 新类型变量 () in
    (变量, 变量, 布尔类型_T)
  | 小于 | 小于等于 | 大于 | 大于等于 ->
    (整数类型_T, 整数类型_T, 布尔类型_T)
  | 逻辑与 | 逻辑或 ->
    (布尔类型_T, 布尔类型_T, 布尔类型_T)

(** 从一元运算符推断类型 *)
let 一元运算符类型 运算符 =
  match 运算符 with
  | 负号 -> (整数类型_T, 整数类型_T)  (* (操作数, 结果) *)
  | 逻辑非 -> (布尔类型_T, 布尔类型_T)

(** 内置函数环境 *)
let 内置环境 = 
  let 环境 = 类型环境.empty in
  let 环境 = 类型环境.add "打印" (函数类型_T (字符串类型_T, 单元类型_T)) 环境 in
  let 环境 = 类型环境.add "读取" (函数类型_T (单元类型_T, 字符串类型_T)) 环境 in
  环境

(** 类型推断 *)
let rec 推断类型 环境 表达式 =
  match 表达式 with
  | 字面量表达式 字面量 ->
    let 类型 = 字面量类型 字面量 in
    (空替换, 类型)
    
  | 变量表达式 变量名 ->
    (try
       let 方案 = 类型环境.find 变量名 环境 in
       let 类型 = 实例化 ([], 方案) in  (* 简化版，暂不支持多态 *)
       (空替换, 类型)
     with Not_found ->
       raise (类型错误 ("未定义的变量: " ^ 变量名)))
       
  | 二元运算表达式 (左表达式, 运算符, 右表达式) ->
    let (替换1, 左类型) = 推断类型 环境 左表达式 in
    let (替换2, 右类型) = 推断类型 (应用替换到环境 替换1 环境) 右表达式 in
    let (期望左类型, 期望右类型, 结果类型) = 二元运算符类型 运算符 in
    let 替换3 = 合一 (应用替换 替换2 左类型) 期望左类型 in
    let 替换4 = 合一 (应用替换 替换3 右类型) (应用替换 替换3 期望右类型) in
    let 最终替换 = 合成替换 (合成替换 (合成替换 替换1 替换2) 替换3) 替换4 in
    (最终替换, 应用替换 最终替换 结果类型)
    
  | 一元运算表达式 (运算符, 表达式) ->
    let (替换, 表达式类型) = 推断类型 环境 表达式 in
    let (期望类型, 结果类型) = 一元运算符类型 运算符 in
    let 替换2 = 合一 表达式类型 期望类型 in
    let 最终替换 = 合成替换 替换 替换2 in
    (最终替换, 应用替换 最终替换 结果类型)
    
  | 函数调用表达式 (函数表达式, 参数列表) ->
    let (替换1, 函数类型) = 推断类型 环境 函数表达式 in
    let 环境1 = 应用替换到环境 替换1 环境 in
    推断函数调用 环境1 函数类型 参数列表 替换1
    
  | 条件表达式 (条件, 那么分支, 否则分支) ->
    let (替换1, 条件类型) = 推断类型 环境 条件 in
    let 替换2 = 合一 条件类型 布尔类型_T in
    let 环境1 = 应用替换到环境 (合成替换 替换1 替换2) 环境 in
    let (替换3, 那么类型) = 推断类型 环境1 那么分支 in
    let 环境2 = 应用替换到环境 替换3 环境1 in
    let (替换4, 否则类型) = 推断类型 环境2 否则分支 in
    let 替换5 = 合一 (应用替换 替换4 那么类型) 否则类型 in
    let 最终替换 = List.fold_left 合成替换 空替换 [替换1; 替换2; 替换3; 替换4; 替换5] in
    (最终替换, 应用替换 最终替换 否则类型)
    
  | 函数表达式 (参数列表, 主体) ->
    推断函数表达式 环境 参数列表 主体
    
  | 让表达式 (变量名, 值表达式, 主体表达式) ->
    let (替换1, 值类型) = 推断类型 环境 值表达式 in
    let 环境1 = 应用替换到环境 替换1 环境 in
    let 泛化类型 = 泛化 环境1 值类型 in
    let 环境2 = 类型环境.add 变量名 (snd 泛化类型) 环境1 in
    let (替换2, 主体类型) = 推断类型 环境2 主体表达式 in
    let 最终替换 = 合成替换 替换1 替换2 in
    (最终替换, 主体类型)
    
  | _ -> raise (类型错误 "不支持的表达式类型")

(** 推断函数调用 *)
and 推断函数调用 环境 函数类型 参数列表 初始替换 =
  let rec 处理参数 函数类型 参数列表 累积替换 =
    match 参数列表 with
    | [] -> (累积替换, 函数类型)
    | 参数 :: 剩余参数 ->
      let 返回类型变量 = 新类型变量 () in
      let 期望函数类型 = 函数类型_T (新类型变量 (), 返回类型变量) in
      let 替换1 = 合一 函数类型 期望函数类型 in
      let 最新替换 = 合成替换 累积替换 替换1 in
      let 环境1 = 应用替换到环境 最新替换 环境 in
      let (替换2, 参数类型) = 推断类型 环境1 参数 in
      let 最终替换 = 合成替换 最新替换 替换2 in
      let 函数类型_T (期望参数类型, 真实返回类型) = 应用替换 最终替换 期望函数类型 in
      let 替换3 = 合一 参数类型 期望参数类型 in
      let 新累积替换 = 合成替换 最终替换 替换3 in
      let 新返回类型 = 应用替换 新累积替换 真实返回类型 in
      处理参数 新返回类型 剩余参数 新累积替换
  in
  处理参数 函数类型 参数列表 初始替换

(** 推断函数表达式 *)
and 推断函数表达式 环境 参数列表 主体 =
  let rec 处理参数 参数列表 环境 参数类型列表 =
    match 参数列表 with
    | [] -> (环境, List.rev 参数类型列表)
    | 参数名 :: 剩余参数 ->
      let 参数类型 = 新类型变量 () in
      let 新环境 = 类型环境.add 参数名 参数类型 环境 in
      处理参数 剩余参数 新环境 (参数类型 :: 参数类型列表)
  in
  let (扩展环境, 参数类型列表) = 处理参数 参数列表 环境 [] in
  let (替换, 主体类型) = 推断类型 扩展环境 主体 in
  let 应用后参数类型列表 = List.map (应用替换 替换) 参数类型列表 in
  let 函数类型 = List.fold_right (fun 参数类型 累积 -> 函数类型_T (参数类型, 累积)) 应用后参数类型列表 主体类型 in
  (替换, 函数类型)
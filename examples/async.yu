(* 骆言异步编程示例 *)

(* 异步函数定义 *)
异步 函数 异步计算 = 函数 n ->
  让 延迟 = 函数 ms ->
    (* 模拟异步延迟 *)
    如果 ms <= 0 那么
      ()
    否则
      延迟 (ms - 1)
  在
    延迟 1000;  (* 延迟1秒 *)
    n * n

(* 并发任务 *)
异步 函数 并发任务1 = 函数 () ->
  打印 "任务1开始";
  让 结果 = 异步计算 5;
  打印 "任务1完成，结果:";
  打印 结果;
  结果

异步 函数 并发任务2 = 函数 () ->
  打印 "任务2开始";
  让 结果 = 异步计算 10;
  打印 "任务2完成，结果:";
  打印 结果;
  结果

(* 主程序 *)
异步 函数 主程序 = 函数 () ->
  打印 "开始并发执行";
  
  (* 创建并发任务 *)
  让 任务1 = 生成 并发任务1 ();
  让 任务2 = 生成 并发任务2 ();
  
  (* 等待任务完成 *)
  让 结果1 = 等待 任务1;
  让 结果2 = 等待 任务2;
  
  (* 合并结果 *)
  让 总和 = 结果1 + 结果2;
  打印 "所有任务完成，总和:";
  打印 总和;
  总和

(* 通道示例 *)
异步 函数 生产者 = 函数 通道 ->
  让 数据 = [1; 2; 3; 4; 5];
  递归 让 发送 = 函数 lst ->
    匹配 lst 与
    | [] -> ()
    | [head; ...tail] ->
      发送到通道 通道 head;
      发送 tail
  在 发送 数据

异步 函数 消费者 = 函数 通道 ->
  递归 让 接收 = 函数 () ->
    让 数据 = 从通道接收 通道;
    匹配 数据 与
    | 无 -> ()
    | 有 value ->
      打印 "接收到:";
      打印 value;
      接收 ()
  在 接收 ()

(* 运行异步程序 *)
让 通道 = 创建通道 ();
生成 生产者 通道;
生成 消费者 通道;

(* 运行主程序 *)
让 最终结果 = 等待 (生成 主程序 ());
打印 "程序执行完成，最终结果:";
打印 最终结果; 
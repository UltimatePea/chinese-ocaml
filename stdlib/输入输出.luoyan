(* 骆言标准库 - 输入输出模块 *)
(* 提供输入输出和文件操作功能 *)

模块 输入输出 = {
  导出: [
    (* 基本输入输出 *)
    ("打印", 函数类型 (类型变量 "a", 单元类型));
    ("打印行", 函数类型 (类型变量 "a", 单元类型));
    ("打印错误", 函数类型 (类型变量 "a", 单元类型));
    ("读取", 函数类型 (单元类型, 字符串类型));
    ("读取行", 函数类型 (单元类型, 字符串类型));
    ("读取字符", 函数类型 (单元类型, 字符类型));
    
    (* 格式化输出 *)
    ("格式化打印", 函数类型 (字符串类型, 函数类型 (列表类型 (类型变量 "a"), 单元类型)));
    ("打印到字符串", 函数类型 (类型变量 "a", 字符串类型));
    
    (* 文件操作 (基础版本) *)
    ("读取文件", 函数类型 (字符串类型, 字符串类型));
    ("写入文件", 函数类型 (字符串类型, 函数类型 (字符串类型, 单元类型)));
    ("追加文件", 函数类型 (字符串类型, 函数类型 (字符串类型, 单元类型)));
    ("文件存在", 函数类型 (字符串类型, 布尔类型));
    
    (* 流控制 *)
    ("刷新输出", 函数类型 (单元类型, 单元类型));
    ("清空输入缓冲", 函数类型 (单元类型, 单元类型));
  ];
  
  语句: [
    (* 基本输入输出实现 *)
    让 打印 = 函数 值 ->
      (* 调用内置打印函数 *)
      内置打印 值;
    
    让 打印行 = 函数 值 ->
      (* 打印值并添加换行符 *)
      打印 值;
      打印 "\n";
    
    让 打印错误 = 函数 值 ->
      (* 打印到错误流 *)
      内置打印错误 值;
    
    让 读取 = 函数 () ->
      (* 读取一行输入，不包含换行符 *)
      内置读取行 ();
    
    让 读取行 = 函数 () ->
      (* 读取一行输入 *)
      内置读取行 ();
    
    让 读取字符 = 函数 () ->
      (* 读取单个字符 *)
      内置读取字符 ();
    
    (* 格式化输出 *)
    让 格式化打印 = 函数 格式字符串 参数列表 ->
      (* 简化实现：基本的格式化打印 *)
      递归 让 格式化辅助 = 函数 模板 参数 ->
        匹配 参数 与
        | [] -> 打印 模板
        | [头部; ...尾部] ->
          (* 简单替换 %s, %d 等占位符 *)
          让 替换后 = 替换占位符 模板 头部 在
          格式化辅助 替换后 尾部
      在 格式化辅助 格式字符串 参数列表;
    
    让 打印到字符串 = 函数 值 ->
      (* 将值转换为字符串表示 *)
      值转字符串 值;
    
    (* 文件操作 (需要底层支持) *)
    让 读取文件 = 函数 文件路径 ->
      (* 读取整个文件内容 *)
      尝试 {
        内置读取文件 文件路径
      } 捕获 异常 -> {
        抛出异常 ("无法读取文件: " + 文件路径 + " - " + 异常消息 异常)
      };
    
    让 写入文件 = 函数 文件路径 内容 ->
      (* 写入内容到文件 *)
      尝试 {
        内置写入文件 文件路径 内容
      } 捕获 异常 -> {
        抛出异常 ("无法写入文件: " + 文件路径 + " - " + 异常消息 异常)
      };
    
    让 追加文件 = 函数 文件路径 内容 ->
      (* 追加内容到文件末尾 *)
      尝试 {
        内置追加文件 文件路径 内容
      } 捕获 异常 -> {
        抛出异常 ("无法追加文件: " + 文件路径 + " - " + 异常消息 异常)
      };
    
    让 文件存在 = 函数 文件路径 ->
      (* 检查文件是否存在 *)
      尝试 {
        内置文件存在 文件路径
      } 捕获 _ -> {
        假
      };
    
    (* 流控制 *)
    让 刷新输出 = 函数 () ->
      (* 刷新输出缓冲区 *)
      内置刷新输出 ();
    
    让 清空输入缓冲 = 函数 () ->
      (* 清空输入缓冲区 *)
      内置清空输入缓冲 ();
    
    (* 辅助函数 *)
    让 替换占位符 = 函数 模板 值 ->
      (* 简化实现：替换第一个占位符 *)
      (* 实际实现需要更复杂的字符串处理 *)
      模板; (* 占位符实现 *)
    
    让 值转字符串 = 函数 值 ->
      (* 将任意值转换为字符串 *)
      匹配 值 与
      | 整数 i -> 整数转字符串 i
      | 浮点 f -> 浮点转字符串 f
      | 字符串 s -> s
      | 布尔 真 -> "真"
      | 布尔 假 -> "假"
      | 列表 lst -> 列表转字符串 lst
      | _ -> "<复杂类型>";
    
    让 列表转字符串 = 函数 lst ->
      (* 将列表转换为字符串表示 *)
      "[" + (连接列表 "; " (映射 值转字符串 lst)) + "]";
    
    让 整数转字符串 = 函数 i ->
      (* 需要底层实现 *)
      内置整数转字符串 i;
    
    让 浮点转字符串 = 函数 f ->
      (* 需要底层实现 *)
      内置浮点转字符串 f;
    
    让 异常消息 = 函数 异常 ->
      (* 提取异常消息 *)
      内置异常消息 异常;
  ];
}

(* 常用IO操作的便捷函数 *)
模块 IO便捷 = {
  导出: [
    ("打印调试", 函数类型 (字符串类型, 函数类型 (类型变量 "a", 类型变量 "a")));
    ("打印列表", 函数类型 (列表类型 (类型变量 "a"), 单元类型));
    ("打印换行", 函数类型 (单元类型, 单元类型));
    ("询问用户", 函数类型 (字符串类型, 字符串类型));
    ("确认操作", 函数类型 (字符串类型, 布尔类型));
    ("读取整数", 函数类型 (单元类型, 整数类型));
    ("读取浮点", 函数类型 (单元类型, 浮点类型));
  ];
  
  语句: [
    (* 调试输出：显示标签和值，然后返回值 *)
    让 打印调试 = 函数 标签 值 ->
      打印 (标签 + ": " + 打印到字符串 值);
      值;
    
    (* 打印列表，每个元素一行 *)
    让 打印列表 = 函数 lst ->
      映射 (函数 元素 -> 打印行 元素) lst;
      ();
    
    (* 打印空行 *)
    让 打印换行 = 函数 () ->
      打印 "\n";
    
    (* 询问用户输入 *)
    让 询问用户 = 函数 问题 ->
      打印 问题;
      打印 " ";
      读取行 ();
    
    (* 确认操作 (y/n) *)
    让 确认操作 = 函数 问题 ->
      让 回答 = 询问用户 (问题 + " (y/n)") 在
      匹配 回答 与
      | "y" | "Y" | "是" | "真" -> 真
      | "n" | "N" | "否" | "假" -> 假
      | _ -> 
        打印 "请输入 y/n 或 是/否";
        确认操作 问题;
    
    (* 读取并解析整数 *)
    递归 让 读取整数 = 函数 () ->
      尝试 {
        让 输入 = 读取行 () 在
        字符串转整数 输入
      } 捕获 异常 -> {
        打印 "请输入一个有效的整数:";
        读取整数 ()
      };
    
    (* 读取并解析浮点数 *)
    递归 让 读取浮点 = 函数 () ->
      尝试 {
        让 输入 = 读取行 () 在
        字符串转浮点 输入
      } 捕获 异常 -> {
        打印 "请输入一个有效的浮点数:";
        读取浮点 ()
      };
    
    (* 辅助转换函数 (需要底层实现) *)
    让 字符串转整数 = 函数 s ->
      内置字符串转整数 s;
    
    让 字符串转浮点 = 函数 s ->
      内置字符串转浮点 s;
  ];
}